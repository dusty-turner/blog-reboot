---
title: Advent of Code 2021
author: Dusty Turner
date: '2021-12-01'
slug: []
categories:
  - R
  - datascience
  - learning
  - teaching
tags:
  - R
  - Data Science
  - learning
  - teaching
cover: /media/advent2.JPG
---

<script src="{{< blogdown/postref >}}index_files/header-attrs/header-attrs.js"></script>


<p>Every year, the great team at <a href="adventofcode.com">Advent of Code</a> lead by <a href="https://twitter.com/ericwastl">ericwastl</a> develops an “Advent calendar of small programming puzzles for a variety of skill sets and skill levels that can be solved in any programming language you like.”</p>
<p>Well, I like R, so in this post I will provide my solutions to the puzzles each day. I plan on using this post to learn and teach and hopefully I am able to stay up-to-date!</p>
<p>A few notes as we get started:</p>
<ul>
<li>Unless otherwise specified, all solutions rely on <code>library(tidyverse)</code>.</li>
<li>All data is saved in the working directory as a <code>.txt</code> file.</li>
<li>I can’t promise my solutions will be the most elegant, but I will only post if they are correct!</li>
</ul>
<p>On to the solutions…</p>
<div id="code-supporting-all-solutions" class="section level4">
<h4>Code supporting all solutions</h4>
<pre class="r"><code>library(tidyverse)
library(furrr)
plan(multicore)</code></pre>
</div>
<div id="day-12" class="section level2">
<h2><a href="https://adventofcode.com/2021/day/12">Day 12</a></h2>
<div id="part-1-2" class="section level4">
<h4>Part 1 / 2</h4>
<pre class="r"><code>x &lt;- ## read in and clean data
  tibble(paths = read_lines(file = &quot;day_12.txt&quot;)) %&gt;% 
  separate(col = paths, into = c(&quot;start&quot;, &quot;end&quot;), sep = &quot;-&quot;) %&gt;% 
  rename_with(toupper) %&gt;% 
  mutate(start = if_else(END == &quot;start&quot; | START == &quot;end&quot;, END, START)) %&gt;% 
  mutate(end = if_else(start == END, START, END)) %&gt;% 
  select(start,end) 

upr_rev_paths &lt;- x %&gt;% ## large caves can go back and forth
  filter(str_detect(start, &#39;[:upper:]&#39;)|str_detect(end, &#39;[:upper:]&#39;)) %&gt;%
  filter(end != &quot;end&quot; &amp; start != &quot;start&quot;) %&gt;%
  select(start = end, end = start)

remove_these &lt;- x %&gt;% ## caves that are a dead end
  pivot_longer(everything()) %&gt;% 
  filter(!str_detect(value, &#39;[:upper:]&#39;)) %&gt;% count(value) %&gt;% filter(n==1) %&gt;% pull(value)

lwr_rev_paths &lt;- x %&gt;% ## small caves reverse path
  filter(end != &quot;end&quot; &amp; start != &quot;start&quot;) %&gt;% 
  filter(!str_detect(start, &#39;[:upper:]&#39;)) %&gt;% 
  filter(!str_detect(end, &#39;[:upper:]&#39;)) %&gt;% 
  select(start = end, end = start) %&gt;% 
  filter(!start %in% remove_these | !end %in% remove_these)

y &lt;- x %&gt;% bind_rows(upr_rev_paths) %&gt;% bind_rows(lwr_rev_paths) %&gt;% distinct() ## all cave paths

first &lt;- x %&gt;% filter(start == &quot;start&quot;) # from the start

join_change_names &lt;- function(x = out, iter_num = 1, part_2 = FALSE){ 
  hold &lt;- x %&gt;% filter(end == &quot;end&quot;) ## splits data to speed up code
  progress &lt;- x %&gt;% filter(end != &quot;end&quot;) ## this is the only data needing processing
  out_1 &lt;- progress %&gt;% 
  left_join(y, by = c(&quot;end&quot; = &quot;start&quot;)) %&gt;% 
    rename_with(~str_c(.,&quot;_x&quot;)) %&gt;% 
    rename_with(~str_c(&quot;end&quot;), .cols = last_col()) %&gt;% 
    rename_with(~str_c(&quot;start&quot;), .cols = starts_with(&quot;start&quot;)) %&gt;% 
    unite(all, everything(), remove = F) 
  if(part_2==FALSE){ ## part 1 criteria
    out &lt;- out_1 %&gt;% 
      filter(str_count(all, &quot;ws&quot;)&lt;=1) %&gt;%
      filter(str_count(all, &quot;kq&quot;)&lt;=1) %&gt;%
      filter(str_count(all, &quot;yr&quot;)&lt;=1) %&gt;%
      filter(str_count(all, &quot;zo&quot;)&lt;=1) %&gt;%
      filter(str_count(all, &quot;np&quot;)&lt;=1) %&gt;%
      filter(str_count(all, &quot;xq&quot;)&lt;=1) %&gt;%
      filter(str_count(all, &quot;ra&quot;)&lt;=1) %&gt;%
      select(-all) %&gt;% 
      bind_rows(hold)}
  if(part_2==TRUE){ ### part 2 criteria
    out &lt;- out_1 %&gt;% 
      filter(str_count(all, &quot;ws&quot;)&lt;=2) %&gt;%
      filter(str_count(all, &quot;kq&quot;)&lt;=2) %&gt;%
      filter(str_count(all, &quot;yr&quot;)&lt;=2) %&gt;%
      filter(str_count(all, &quot;zo&quot;)&lt;=2) %&gt;%
      filter(str_count(all, &quot;np&quot;)&lt;=2) %&gt;%
      filter(str_count(all, &quot;xq&quot;)&lt;=2) %&gt;%
      filter(str_count(all, &quot;ra&quot;)&lt;=2) %&gt;%
      mutate(ws = str_count(all, &quot;ws&quot;)==2) %&gt;%
      mutate(kq = str_count(all, &quot;kq&quot;)==2) %&gt;%
      mutate(yr = str_count(all, &quot;yr&quot;)==2) %&gt;%
      mutate(zo = str_count(all, &quot;zo&quot;)==2) %&gt;%
      mutate(np = str_count(all, &quot;np&quot;)==2) %&gt;%
      mutate(xq = str_count(all, &quot;xq&quot;)==2) %&gt;%
      mutate(ra = str_count(all, &quot;ra&quot;)==2) %&gt;%
      mutate(total = ws + kq + yr + zo + np + xq + ra) %&gt;% 
      filter(total &lt;= 1) %&gt;% 
      select(-all,-ws,-kq,-yr,-zo,-np,-xq,-ra,-total) %&gt;% 
      bind_rows(hold)}
  return(out)}

1:20 %&gt;% reduce(.f = join_change_names, .init = first) </code></pre>
</div>
</div>
<div id="day-11" class="section level2">
<h2><a href="https://adventofcode.com/2021/day/11">Day 11</a></h2>
<div id="part-1" class="section level4">
<h4>Part 1</h4>
<p>In previous attempts, I’ve moved through the entire plane making changes as I get to them. This time, I took a page from <a href="https://twitter.com/drob">David Robinsion’s</a> playbook and used <code>crossing()</code>. I then used a while loop to progress through the octopus stages</p>
<pre class="r"><code>x &lt;-
  tibble(x = (read_lines(&quot;day_11.txt&quot;))) %&gt;% 
  mutate(row = row_number()) %&gt;% 
  mutate(value = str_split(x,&quot;&quot;)) %&gt;% 
  unnest(value) %&gt;% 
  mutate(value = as.numeric(value)) %&gt;% 
  group_by(row) %&gt;% 
  mutate(col = row_number()) %&gt;% 
  ungroup() %&gt;% 
  relocate(value, .after = col) %&gt;% 
  select(-x)

adj &lt;- expand.grid(xd = c(-1,0,1), yd = c(-1,0,1))

adjacent &lt;- function(x){
  d &lt;- x %&gt;% distinct(row,col,value)
  d2 &lt;- x %&gt;% distinct(row,col,value)
  d %&gt;% 
    crossing(adj) %&gt;% 
    mutate(row2 = row +xd,
           col2 = col + yd) %&gt;%
    arrange(row,col) %&gt;% 
    inner_join(d2, by = c(row2 = &quot;row&quot;, col2 = &quot;col&quot;), suffix = c(&quot;&quot;, &quot;2&quot;)) %&gt;% 
    filter(row != row2 | col != col2)  
}

flash_octopus &lt;- function(x = x, iteration = 1) {
  x &lt;- x$x %&gt;%
    adjacent() %&gt;%
    mutate(across(.cols = c(&quot;value&quot;, &quot;value2&quot;), .fns = ~ . + 1))
  tens &lt;- 1
  while (tens != 0) {
    x &lt;- x %&gt;%
      group_by(row, col) %&gt;%  mutate(add_this_many = sum(value2 &gt;= 10)) %&gt;% ungroup() %&gt;%
      mutate(value = ifelse(value &gt;= 10,-100, value)) %&gt;%
      mutate(value = value + add_this_many) %&gt;%
      adjacent()
    tens &lt;- x %&gt;% distinct(row, col, value) %&gt;% filter(value &gt;= 10) %&gt;% nrow()
  }
  flashes &lt;- x %&gt;% distinct(row, col, value) %&gt;% count(did_flash = value &lt; 0) %&gt;% filter(did_flash) %&gt;% pull(n)
  if (length(flashes) == 0) {flashes &lt;- 0}
  x &lt;- x %&gt;% mutate(value = ifelse(value &lt; 0, 0, value))
  x &lt;- list(x = x, flashes = flashes)
  return(x)
}

x &lt;- list(x = x, flashes = 0)

## Answer 1
accumulate(1:100, .f = flash_octopus, .init = x) %&gt;% one_hundred %&gt;% map(2) %&gt;% unlist() %&gt;% sum()</code></pre>
</div>
<div id="part-2" class="section level4">
<h4>Part 2</h4>
<p>For part 2, let it run longer and find the first element that has 100 flashes.</p>
<pre class="r"><code>three_hundred &lt;- accumulate(1:300, .f = flash_octopus, .init = x)

which(unlist(map(three_hundred, 2)) == 100)[1] - 1</code></pre>
<p>I also want to provide this function that proved helpful in viewing the matrix throughout.</p>
<pre class="r"><code>see_matrix &lt;- function(data = x){
  data %&gt;% 
    distinct(row, col, value) %&gt;% 
    select(row,col,value) %&gt;% 
    pull(value) %&gt;% 
    matrix(nrow = 10, byrow = T)
}</code></pre>
</div>
</div>
<div id="day-10" class="section level2">
<h2><a href="https://adventofcode.com/2021/day/10">Day 10</a></h2>
<div id="part-1-1" class="section level4">
<h4>Part 1</h4>
<p>I use a while loop to remove all ‘open’ ‘close’ pairings. This helps find both corrupted and broken chunks. I find the corrupted chunks and apply the scoring mechanism.</p>
<pre class="r"><code>input &lt;-
  tibble(chunks = read_lines(&quot;day_10.txt&quot;))

syntax_error_points &lt;- ## points for each bracket type
  tibble(chunks = c(&quot;)&quot;, &quot;]&quot;, &quot;}&quot;, &quot;&gt;&quot;),
         points = c(3, 57, 1197, 25137)
         )

input_list &lt;- list(NULL, input) ## prepare list for iteration

i &lt;- 2 ## initialize iterator 
while (!isTRUE(all.equal(input_list[i], input_list[i - 1]))) {
  input &lt;-  input %&gt;%
    mutate(chunks = str_remove_all(string = chunks, pattern = &quot;&lt;&gt;|\\[\\]|\\(\\)|\\{\\}&quot;))
  i = i + 1
  input_list[[i]] &lt;- input
} ## this iteratively removes all open/closed pairings until the df does not change between iterations

input_list %&gt;% tail(1) %&gt;% pluck(1) %&gt;% ## select the last list
  mutate(chunks = str_remove_all(string = chunks, pattern = &quot;&lt;|\\[|\\(|\\{&quot;)) %&gt;% ## remove openings
  filter(chunks != &quot;&quot;) %&gt;% ## remove extraneous lines
  mutate(chunks = str_sub(chunks, 1, 1)) %&gt;% ## select the first opening
  count(chunks) %&gt;% ## count them up!
  left_join(syntax_error_points, by = &quot;chunks&quot;) %&gt;%  ## join in points
  summarise(score = sum(n * points)) ## score the process</code></pre>
</div>
</div>
<div id="part-2-1" class="section level2">
<h2>Part 2</h2>
<p>I take the incomplete chunks from the previous part and map over the score_points function for the final answer.</p>
<pre class="r"><code>incomplete_df &lt;- ## identify chunks with incomplete strings
  input_list %&gt;% tail(1) %&gt;% pluck(1) %&gt;% ## selects list element with all open/closed pairs removed
  mutate(chunks = str_remove_all(string = chunks, pattern = &quot;&lt;|\\[|\\(|\\{&quot;)) %&gt;% ## removes opens
  mutate(incomplete_strings = row_number()) %&gt;% ## ids each pattern
  filter(chunks == &quot;&quot;) %&gt;% ## removes extraneous lines
  select(id = chunks, incomplete_strings) ## now have df with incomplete strings identified

matching_df &lt;- ## create scoring df for joining later
  tibble(
    chunks = c(&quot;(&quot;, &quot;[&quot;, &quot;{&quot;, &quot;&lt;&quot;),
    right = c(&quot;)&quot;, &quot;]&quot;, &quot;}&quot;, &quot;&gt;&quot;),
    points = c(1, 2, 3, 4))

incomplete_list &lt;-  ## creates list of points
  input %&gt;%  mutate(incomplete_strings = row_number()) %&gt;%
  semi_join(incomplete_df, by = &quot;incomplete_strings&quot;) %&gt;% ## only keep the chunks that are incomplete
  separate_rows(chunks, sep = &quot;&quot;) %&gt;% 
  left_join(matching_df, by = &quot;chunks&quot;) %&gt;% ## add in points
  filter(!is.na(right)) %&gt;%
  group_by(incomplete_strings) %&gt;% mutate(row_num = row_number()) %&gt;% arrange(desc(row_num)) %&gt;%
  select(-row_num) %&gt;% ## puts the chunks in the right order
  group_split() %&gt;% ## splits them for future map function
  map(.f = ~ pull(.data = .x, points)) ## only keeps the column we want

score_points &lt;- function(current_vector = points, index) {
    current_vector[index] &lt;- current_vector[index - 1] * 5 + current_vector[index]
    return(current_vector)} ## function to execute partial scoring function

score_everything &lt;- function(data) {
  2:length(data) %&gt;%
    reduce(.f = score_points, .init = data) %&gt;%
    tail(1)} ## function which scores entire vector

incomplete_list %&gt;%
  map_dbl(.f = ~ score_everything(data = .x)) %&gt;%
  sort() %&gt;% median() ## maps all lists over scoring function</code></pre>
</div>
<div id="day-9" class="section level2">
<h2><a href="https://adventofcode.com/2021/day/9">Day 9</a></h2>
<div id="part-1-3" class="section level4">
<h4>Part 1</h4>
<p>To find the number of low points I map across a function that determines if each place is a depression. After the identification, I use the problems formula to sum up the risk levels.</p>
<pre class="r"><code>input &lt;-
  matrix(read_lines(&quot;02_data/day_9.txt&quot;)) %&gt;% 
  strsplit(&quot;&quot;) %&gt;% unlist() %&gt;% as.numeric() %&gt;% matrix(byrow = T, nrow = 100) 

checker &lt;- function(row, col){
  if(col &lt; ncol(input)){right &lt;- input[row,col]-input[row,col+1] &lt; 0}else{right&lt;-1} # check right
  if(col != 1)         {left  &lt;- input[row,col]-input[row,col-1] &lt; 0}else{left&lt;-1}  # check left
  if(row != 1)         {upper &lt;- input[row,col]-input[row-1,col] &lt; 0}else{upper&lt;-1} # check up
  if(row &lt; nrow(input)){lower &lt;- input[row,col]-input[row+1,col] &lt; 0}else{lower&lt;-1} # check down
  
  out &lt;- tibble(number = input[row,col], row = row, col = col, 
                num_increase = sum(right,left,upper,lower)) # this sums every direction that has an increase
  return(out)
}

future_map2_dfr(.x = sort(rep(1:nrow(input),ncol(input))),
                .y = rep(1:ncol(input),nrow(input)),
                .f = ~checker(row = .x,col = .y), .progress = T) %&gt;% 
  filter(num_increase == 4) %&gt;% 
  mutate(number = number + 1) %&gt;% 
  summarise(answer = sum(number))</code></pre>
</div>
<div id="part-2-2" class="section level4">
<h4>Part 2</h4>
<p>I again map over a function that looks in all directions and determines if it is touching a place that is not a 9. I count the basins one at a time and add up the size of the basins.</p>
<pre class="r"><code>id_reduce_count_replace &lt;- function(input){
  input &lt;- unique.matrix(input$input, MARGIN = 1) ## gets rid of rows already searched to speed up code
  input &lt;- t(input) %&gt;% str_c(collapse = &quot;&quot;) %&gt;% str_replace(pattern = &quot;[^X]&quot;, replacement = &quot;B&quot;) %&gt;% 
    str_split(pattern = &quot;&quot;) %&gt;% unlist() %&gt;% matrix(byrow = T, nrow = nrow(input))
    ## above determines first spot of basin in top row
  identified_basin &lt;- reduce2(.x = ## there is probably a better way to come up with these vectors to map over
                                c(sort(rep(1:nrow(input),ncol(input))),
                                  rev(sort(rep(1:nrow(input),ncol(input)))),
                                  sort(rep(1:nrow(input),ncol(input))),
                                  rev(sort(rep(1:nrow(input),ncol(input))))),
                              .y = 
                                c(rep(1:ncol(input),nrow(input)),
                                  rep(1:ncol(input),nrow(input)),
                                  rev(rep(1:ncol(input),nrow(input)),
                                  rep(1:ncol(input),nrow(input)))), 
                              .f = sweep, .init = input) ## iterates over all places on matrix to determine if basin
  
  basin_size &lt;- identified_basin %&gt;%  str_count(&quot;B&quot;) %&gt;% sum() # identify to of new basin

  input &lt;- str_replace_all(identified_basin,&quot;B&quot;, &quot;X&quot;) %&gt;% matrix(byrow = F, nrow = nrow(input)) # delete basin tracking
  
  if(sum(str_count(input, pattern = &quot;X&quot;))==sum(nchar(input))){message(&quot;Finished&quot;)} # create an error if complete

  return(list(input = input, basin_size = basin_size))
}

initial &lt;-
  matrix(read_lines(&quot;02_data/day_9.txt&quot;)) %&gt;%
  strsplit(&quot;&quot;) %&gt;% unlist() %&gt;% str_replace_all(pattern = &quot;9&quot;,&quot;X&quot;) %&gt;% 
  matrix(byrow = T, nrow = 100) 

input &lt;- list(input = initial, basin_size = NULL)

sweep &lt;- function(input, row, col){
  if(col != ncol(input))  {input[row,col][input[row,col+1]==&quot;B&quot; &amp;&amp; input[row,col] !=&quot;X&quot;] &lt;- &quot;B&quot;} # look right
  if(row != nrow(input))  {input[row,col][input[row+1,col]==&quot;B&quot; &amp;&amp; input[row,col] !=&quot;X&quot;] &lt;- &quot;B&quot;} # look down
  if(col != 1)            {input[row,col][input[row,col-1]==&quot;B&quot; &amp;&amp; input[row,col] !=&quot;X&quot;] &lt;- &quot;B&quot;} # look left
  if(row != 1)            {input[row,col][input[row-1,col]==&quot;B&quot; &amp;&amp; input[row,col] !=&quot;X&quot;] &lt;- &quot;B&quot;} # look up
  return(input)
}

tictoc::tic()
accumulate(.x = 1:225, .f = id_reduce_count_replace, .init = input) %&gt;% map(2) %&gt;% unlist() %&gt;% sort() %&gt;% tail(3) %&gt;% prod()
tictoc::toc()
## took just under 300 seconds</code></pre>
</div>
</div>
<div id="day-8" class="section level2">
<h2><a href="https://adventofcode.com/2021/day/8">Day 8</a></h2>
<div id="part-1-4" class="section level4">
<h4>Part 1</h4>
<p>For part 1, I separate the string to grab the element of interest, I count the length of the unique output values, and count how many time this happens.</p>
<pre class="r"><code>tibble(entry = read_lines(&quot;day_8.txt&quot;)) %&gt;%
  separate(col = entry, into = c(&quot;NA&quot;,&quot;output&quot;),sep = &quot; \\| &quot;) %&gt;% 
  mutate(id = row_number()) %&gt;%
  separate_rows(output, sep = &quot; &quot;) %&gt;% 
  mutate(length = nchar(output)) %&gt;% 
  count(length) %&gt;%
  filter(length %in% c(2,3,4,7)) %&gt;%
  summarise(sum = sum(n))</code></pre>
</div>
<div id="part-2-3" class="section level4">
<h4>Part 2</h4>
<p>Part 2 is a little less elegant. I extract the signal patterns and use a set of functions to identify which strings become each number. I then map over all entrys to identify the letters. Next I join in the output values to determine the numerical output values.</p>
<pre class="r"><code>initial &lt;-
  tibble(entry = read_lines(&quot;day_8.txt&quot;)) %&gt;%
  separate(col = entry, into = c(&quot;signal&quot;,&quot;output&quot;),sep = &quot; \\| &quot;) %&gt;% 
  mutate(id = row_number()) %&gt;%
  separate_rows(signal, sep = &quot; &quot;) %&gt;% 
  rowwise() %&gt;% 
  mutate(signal = str_c(sort(unlist(str_split(signal,&quot;&quot;))), collapse = &quot;&quot;)) %&gt;% ungroup() %&gt;% 
  select(-output)

output_tbl &lt;-
  tibble(entry = read_lines(&quot;day_8.txt&quot;)) %&gt;%
  separate(col = entry, into = c(&quot;signal&quot;,&quot;output&quot;),sep = &quot; \\| &quot;) %&gt;% 
  mutate(id = row_number()) %&gt;%
  separate_rows(output, sep = &quot; &quot;) %&gt;% 
  rowwise() %&gt;% 
  mutate(output = str_c(sort(unlist(str_split(output,&quot;&quot;))), collapse = &quot;&quot;)) %&gt;% ungroup() %&gt;% 
  select(-signal) %&gt;% 
  group_by(id) %&gt;% 
  summarise(output = str_c(output, collapse = &quot; &quot;)) %&gt;% 
  ungroup() %&gt;% 
  separate_rows(output, sep = &quot; &quot;) %&gt;% 
  mutate(order = row_number())

identify_obvious &lt;- function(initial){
  out &lt;- initial %&gt;% 
    mutate(number = case_when(nchar(signal) == 2 ~ 1,
                              nchar(signal) == 3 ~ 7,
                              nchar(signal) == 4 ~ 4,
                              nchar(signal) == 7 ~ 8,
                              TRUE ~ 0
                              )) %&gt;% 
    filter(number !=0) %&gt;% 
    arrange(number)
  return(out)
}
  
identify_3 &lt;- function(known, initial){
  seven &lt;-
    known  %&gt;% filter(number %in% c(7)) %&gt;% 
    pull(signal) %&gt;% str_split(&quot;&quot;) %&gt;% unlist()
  three &lt;-  
    initial %&gt;% 
    filter(nchar(signal) == 5) %&gt;% 
    mutate(split = signal) %&gt;% 
    separate_rows(split, sep = &quot;&quot;) %&gt;% 
    filter(split %in% seven) %&gt;% 
    group_by(signal) %&gt;% filter(n() == 3) %&gt;% ungroup(signal) %&gt;% 
    distinct(signal, .keep_all = T) %&gt;% 
    select(-split) %&gt;% 
    mutate(number = 3) %&gt;% 
    bind_rows(known) %&gt;% 
    arrange(number)
  return(three)
}

identify_9 &lt;- function(known, initial){
  three &lt;-
    known  %&gt;% filter(number %in% c(3)) %&gt;% 
    pull(signal) %&gt;% str_split(&quot;&quot;) %&gt;% unlist()
  nine &lt;-
    initial %&gt;% 
    filter(nchar(signal) == 6) %&gt;% 
    mutate(split = signal) %&gt;% 
    separate_rows(split, sep = &quot;&quot;) %&gt;% 
    filter(split %in% three) %&gt;% 
    group_by(signal) %&gt;% filter(n() == 5) %&gt;% ungroup(signal) %&gt;% 
    distinct(signal, .keep_all = T) %&gt;% 
    select(-split) %&gt;% 
    mutate(number = 9) %&gt;% 
    bind_rows(known) %&gt;% 
    arrange(number)
  return(nine)
}

identify_0 &lt;- function(known, initial){
  one &lt;-
    known  %&gt;% 
    filter(number %in% c(1)) %&gt;% 
    pull(signal) %&gt;% 
    str_split(&quot;&quot;) %&gt;% unlist()
  zero &lt;-
    initial %&gt;% 
    anti_join(known, by = c(&quot;signal&quot;, &quot;id&quot;)) %&gt;% 
    filter(nchar(signal) == 6) %&gt;%   
    mutate(split = signal) %&gt;% 
    separate_rows(split, sep = &quot;&quot;) %&gt;% 
    filter(split %in% one) %&gt;% 
    group_by(signal) %&gt;% filter(n() == 2) %&gt;% ungroup(signal) %&gt;% 
    distinct(signal, .keep_all = T) %&gt;% 
    select(-split) %&gt;% 
    mutate(number = 0) %&gt;% 
    bind_rows(known) %&gt;% 
    arrange(number)
  return(zero)
}

identify_6 &lt;- function(known, initial){
  known &lt;-
    initial %&gt;% 
    anti_join(known, by = c(&quot;signal&quot;, &quot;id&quot;)) %&gt;% 
    filter(nchar(signal) == 6) %&gt;%
    mutate(number = 6) %&gt;% 
    bind_rows(known) %&gt;% 
    arrange(number)
  return(known)
}

identify_5_2 &lt;- function(known, initial){
  part &lt;-
    known %&gt;% 
    filter(number %in% c(1,4)) %&gt;% 
    separate_rows(signal, sep = &quot;&quot;) %&gt;% 
    group_by(signal) %&gt;% filter(n()==1) %&gt;% 
    pull(signal) %&gt;% str_split(&quot;&quot;) %&gt;% unlist()
  last &lt;- 
    initial %&gt;% 
    anti_join(known, by = c(&quot;signal&quot;, &quot;id&quot;)) %&gt;% 
    mutate(side = signal) %&gt;% 
    separate_rows(side, sep = &quot;&quot;)  %&gt;% 
    filter(side %in% part) %&gt;% 
    group_by(signal) %&gt;% 
    mutate(number = if_else(n()==2,5,2)) %&gt;% 
    ungroup() %&gt;% select(-side) %&gt;% distinct() %&gt;% 
    bind_rows(known) %&gt;% 
    arrange(number)
return(last)
}

all_together &lt;- function(initial) {
  all &lt;-
    initial %&gt;%
    identify_obvious() %&gt;%
    identify_3(initial = initial) %&gt;%
    identify_9(initial = initial) %&gt;%
    identify_0(initial = initial) %&gt;%
    identify_6(initial = initial) %&gt;%
    identify_5_2(initial = initial)
  return(all)
}

initial %&gt;% group_split(id) %&gt;% 
  map_df(~all_together(initial = .x)) %&gt;% 
  left_join(output_tbl, by = c(&quot;signal&quot; = &quot;output&quot;, &quot;id&quot; = &quot;id&quot;)) %&gt;% 
  filter(!is.na(order)) %&gt;% arrange(order) %&gt;% 
  group_by(id) %&gt;% 
  summarise(signal = str_c(signal, collapse = &quot; &quot;), 
            number = as.numeric(str_c(number, collapse = &quot;&quot;))) %&gt;% 
  summarise(solution = sum(number))</code></pre>
</div>
</div>
<div id="day-7" class="section level2">
<h2><a href="https://adventofcode.com/2021/day/7">Day 7</a></h2>
<div id="part-1-5" class="section level4">
<h4>Part 1</h4>
<p>To solve part 1, I create a function that finds the distance between all points to a specific point, map across all specific points, and then find the minimum distance.</p>
<!-- dat <- read_lines("content/post/2021-12-01-advent-of-code-2021/day_7.txt") %>% str_split(",") %>% unlist() %>% as.numeric() -->
<pre class="r"><code>dat &lt;- as.numeric(unlist(str_split(read_lines(&quot;02_data/day_7.txt&quot;),&quot;,&quot;))) 

distance &lt;- function(data = dat, position) {
  out &lt;- sum(abs(data - position))
  return(out)
}

min(dat):max(dat) %&gt;% 
  map_dbl(.f = ~distance(data = dat, position = .x)) %&gt;% min()</code></pre>
</div>
<div id="part-2-4" class="section level4">
<h4>Part 2</h4>
<p>I alter the distance formula to find the triangular number between two numbers. This can also be factored into the binomial coefficient with the upper index being the distance between the numbers and 2 as the lower index.</p>
<pre class="r"><code>distance_plus &lt;- function(data = dat, position) {
  n &lt;-abs(data-position)+1
  out &lt;- sum(choose(n,2))
  return(out)
}

min(dat):max(dat) %&gt;% 
  map_dbl(.f = ~distance_plus(data = dat, position = .x)) %&gt;% min()</code></pre>
</div>
<div id="code-golfing" class="section level4">
<h4>Code Golfing</h4>
<p>This last code chunk is my attempt at ‘code golfing’ - aka - how succinct can I make my code. I can answer both parts with fairly brief code, but I think its less understandable.</p>
<pre class="r"><code>fuel_calculation &lt;- function(data = dat, position, type) {
  if(type == &quot;distance&quot;){out &lt;- tibble(fuel = sum(abs(data - position)), position = position, type)}
  if(type == &quot;triangular&quot;){out &lt;- tibble(fuel = sum(choose(abs(data-position)+1,2)), position = position, type)}
  return(out)
}

rep(min(dat):max(dat), 2) %&gt;%
  map2_dfr(.y = c(rep(&quot;distance&quot;, length(min(dat):max(dat))), rep(&quot;triangular&quot;, length(min(dat):max(dat)))),
    .f = ~ fuel_calculation(data = dat,position = .x, type = .y)) %&gt;%
  group_split(type) %&gt;%
  map( ~ filter(.x, fuel == min(fuel)))</code></pre>
</div>
</div>
<div id="day-6" class="section level2">
<h2><a href="https://adventofcode.com/2021/day/6">Day 6</a></h2>
<div id="part-1-and-2" class="section level4">
<h4>Part 1 and 2</h4>
<p>My gut instinct is to always think in ‘tidy’ coding concepts. This will get the answer, but when moving from part 1 to part 2, the time it takes to run the code becomes computationally infeasible with my computer. I’ll show my 3 attempts.</p>
</div>
<div id="strike-1" class="section level4">
<h4>Strike 1</h4>
<pre class="r"><code>initial_fish &lt;- tibble(fish = read_lines(&quot;day_6.txt&quot;)) %&gt;%
  separate_rows(fish, sep = &quot;,&quot;, convert = T) 

progress_day &lt;- function(fish = initial_fish, after_day = 1){
fish &lt;-
  fish %&gt;% 
  mutate(fish = ifelse(fish &lt;= 0 , &quot;6,8&quot;, fish-1)) %&gt;% 
  separate_rows(fish, sep = &quot;,&quot;, convert = T) 
return(fish)
}

tictoc::tic()
ans &lt;- 1:80 %&gt;% 
# ans &lt;- 1:256 %&gt;% nope!
  reduce(.f = progress_day, .init = initial_fish) %&gt;% nrow()
tictoc::toc()</code></pre>
<pre><code>## 40.14 sec elapsed</code></pre>
<p>My second attempt was a ‘non-tidy’ solution, but part 2 also took too long to run.</p>
</div>
<div id="strike-2" class="section level4">
<h4>Strike 2</h4>
<pre class="r"><code>initial_fish &lt;- as.numeric(unlist(strsplit(readr::read_lines(&quot;day_6.txt&quot;),&quot;,&quot;)))

progress_day &lt;- function(fish = initial_fish, after_day = 1) {
  
  add_fish &lt;- sum(fish == 0)
  next_day &lt;- fish - 1
  next_day[next_day &lt; 0] &lt;- 6

  out &lt;- c(next_day, rep(8, add_fish))
return(out)  
}

tictoc::tic()
ans &lt;- 1:150 %&gt;% 
# ans &lt;- 1:256 %&gt;% faster, but nope! 
  reduce(.f = progress_day, .init = initial_fish) %&gt;% length()
tictoc::toc() </code></pre>
<pre><code>## 36.45 sec elapsed</code></pre>
<p>Lastly, instead of building out a vector for each fish, I decided to count the number of fish at each state of their birthing countdown. This make things work nice and quick.</p>
</div>
<div id="success" class="section level4">
<h4>Success!</h4>
<pre class="r"><code>fish &lt;- as.numeric(unlist(strsplit(read_lines(&quot;day_6.txt&quot;),&quot;,&quot;)))
 
initial_fish &lt;- c(
length(fish[fish==8]),
length(fish[fish==7]),
length(fish[fish==6]),
length(fish[fish==5]),
length(fish[fish==4]),
length(fish[fish==3]),
length(fish[fish==2]),
length(fish[fish==1]),
length(fish[fish==0]))

progress_day &lt;- function(fish = initial_fish, after_day = 1){

births = fish[9]
get_older &lt;- replace_na(lag(fish),0)
out &lt;- c(births, get_older[2], get_older[3]+births, get_older[-c(1:3)])
return(out)
}

tictoc::tic()
ans &lt;- 1:256 %&gt;% 
  reduce(.f = progress_day, .init = initial_fish) %&gt;% sum()
tictoc::toc()</code></pre>
<pre><code>## 0.01 sec elapsed</code></pre>
</div>
</div>
<div id="day-5" class="section level2">
<h2><a href="https://adventofcode.com/2021/day/5">Day 5</a></h2>
<div id="part-1-6" class="section level4">
<h4>Part 1</h4>
<p>For this problem, I created a matrix to track the lines of the hydrothermic vents. In part one, each line was straight so I was able to build this matrix fairly simply. I had to create a toggle for vents that were horizontal vs vertical.</p>
<pre class="r"><code>movements &lt;-
  tibble(directions = read_lines(&quot;day_5.txt&quot;)) %&gt;%
  mutate(directions = str_replace_all(string = directions, pattern = &quot; -&gt; &quot;, &quot;,&quot;)) %&gt;% 
  separate(col = directions, into = c(&quot;x1&quot;, &quot;y1&quot;, &quot;x2&quot;, &quot;y2&quot;), sep = &quot;,&quot;, convert = T) %&gt;% 
  select(x1,x2,y1,y2) 

create_lines &lt;- function(move){

if(move$y1==move$y2) {
  xlow  &lt;- min(move$x1, min(move$x2))
  xhigh &lt;- max(move$x1, min(move$x2))
  ylow  &lt;- min(move$y1, min(move$y2))
  yhigh &lt;- max(move$y1, min(move$y2))
  byrow &lt;- T # for horizontal vents
} else if (move$x1 == move$x2) {
  ylow  &lt;- min(move$x1, min(move$x2))
  yhigh &lt;- max(move$x1, min(move$x2))
  xlow  &lt;- min(move$y1, min(move$y2))
  xhigh &lt;- max(move$y1, min(move$y2))
  byrow &lt;- F # for vertical vents
}
out &lt;- matrix(c(
  rep(rep(0,1000),ylow), ## zeroes before row/col
  c(rep(0,xlow),rep(1,xhigh-xlow+1), rep(0,999-xhigh)), ## row/col of 1s
  rep(rep(0,1000),999-ylow) ## zeroes after row/col
  ), byrow = byrow, nrow = 1000, ncol = 1000)
return(out)
}

movements %&gt;% 
  filter(x1==x2 | y1==y2) %&gt;% 
  group_split(row_number(), .keep = F) %&gt;% 
  purrr::map(~create_lines(lines = .x)) %&gt;% 
  reduce(`+`) %&gt;% as_tibble() %&gt;% 
  pivot_longer(cols = everything()) %&gt;% 
  filter(value &gt;=2) %&gt;% 
  count()</code></pre>
</div>
<div id="part-2-5" class="section level4">
<h4>Part 2</h4>
<p>In this part some of the vents were diagonal. I used the first function to mark the straight vents and created a second function to trace the ones at an angle. I had to condition this off the top right to bottom left lines verses the top left to bottom right lines.</p>
<pre class="r"><code>cross_routes &lt;- function(move){

  xlow  &lt;- min(move$x1, min(move$x2))
  xhigh &lt;- max(move$x1, min(move$x2))
  ylow  &lt;- min(move$y1, min(move$y2))
  yhigh &lt;- max(move$y1, min(move$y2))

mat &lt;- matrix(rep(0,1000000), ncol = 1000) # create a 1000 x 1000 matrix
if((move$x2&gt;move$x1 &amp; move$y2&gt;move$y1) | (move$x2&lt;move$x1 &amp; move$y2&lt;move$y1)){
  for (i in 1:length(xlow:xhigh)) {
    mat[ylow+i,xlow+i] &lt;- 1
  }
} else{ ## vent is top left to bottom right
  for (i in 1:length(xlow:xhigh)) {
    mat[ylow+i,xhigh+2-i] &lt;- 1
  }
}## determine if vent is top right to bottom left
return(mat)
}

striaght_lines &lt;- # from part 1
  movements %&gt;% 
  filter(x1==x2 | y1==y2) %&gt;% # straight lines
  group_split(row_number(), .keep = F) %&gt;% 
  purrr::map(~create_lines(lines = .x)) %&gt;% 
  reduce(`+`) 

diagonal_lines &lt;-
  movements %&gt;%
  filter(x1!=x2 &amp; y1!=y2) %&gt;% # diagonal lines
  group_split(row_number(), .keep = F) %&gt;% 
  purrr::map(~cross_routes(move = .x)) %&gt;% 
  reduce(`+`) 
 
as_tibble(striaght_lines + diagonal_lines) %&gt;% 
  pivot_longer(cols = everything()) %&gt;%
  filter(value &gt;=2) %&gt;%
  count()</code></pre>
</div>
</div>
<div id="day-4" class="section level2">
<h2><a href="https://adventofcode.com/2021/day/4">Day 4</a></h2>
<p>I feel like this could be done more simply, but today I create a function that take the bingo number, adjudicates each board, determines if there is a winner, then outputs the next board. Then we use <code>purrr::accumulate()</code> and <code>purrr::possibly()</code> to handle errors that I intentionally create.</p>
<div id="part-1-7" class="section level4">
<h4>Part 1</h4>
<pre class="r"><code>data &lt;- read_lines(&quot;day_4.txt&quot;)

selections &lt;-
  data[1] %&gt;% str_split(&quot;,&quot;) %&gt;% unlist() %&gt;% str_pad(2,&quot;left&quot;) %&gt;% str_pad(3,&quot;right&quot;)

boards &lt;-
  tibble(cards = data[-1]) %&gt;% 
  filter(cards != &quot;&quot;) %&gt;%
  mutate(cards = str_squish(cards)) %&gt;% 
  transmute(col = str_split_fixed(cards, pattern = &quot; &quot;, n = 5)) %&gt;% 
  pull(col) %&gt;% as_tibble() %&gt;% 
  mutate(across(.cols = everything(),.fns = ~str_pad(str_pad(.,2,&quot;left&quot;),3,&quot;right&quot;))) %&gt;% 
  mutate(card_number = sort(rep(1:(n()/5),5))) %&gt;% 
  mutate(winner = 0)

boards_list &lt;- list(boards = boards, win_card = integer(0))

mark_board &lt;- function(boards_list = boards_list, selection = selections[1]){
  if(length(boards_list$win_card) &gt; 0){stop(boards_list)}
  boards &lt;- boards_list$boards
  marked &lt;-
    boards %&gt;% 
    mutate(across(.cols = 1:5, .fns = ~str_replace_all(string = ., pattern = selection, replacement = &quot;X&quot;)))
  row_win_card &lt;-
    marked %&gt;%
    mutate(row_bingo = str_count(str_c(V1,V2,V3,V4,V5),&quot;X&quot;)) %&gt;% 
    filter(row_bingo==5)  %&gt;% 
    pull(card_number)
  col_win_card &lt;-
    marked %&gt;% 
    mutate(across(.cols = V1:V5, .fns = ~ifelse(.==&quot;X&quot;,1,0))) %&gt;% 
    group_by(card_number) %&gt;% 
    summarise(across(everything(), ~sum(.))) %&gt;% 
    filter(V1 ==5|V2 ==5|V3 ==5|V4 ==5|V5 ==5) %&gt;% 
    pull(card_number)
  card_number &lt;- ifelse(length(row_win_card) &gt; 0, row_win_card, ifelse(length(col_win_card) &gt; 0, col_win_card, integer(0)))
  if(is.na(card_number)){card_number &lt;- integer(0)}
  out &lt;- list(boards = marked, win_card = card_number, selection = selection)
  return(out)
}

mark_board_poss &lt;- possibly(mark_board, otherwise = NULL)

winning_card &lt;- 
selections %&gt;% 
  accumulate(.f = mark_board_poss, .init = boards_list) %&gt;% 
  discard(is.null) %&gt;% 
  pluck(length(.)) 

winning_card$boards %&gt;% 
  filter(card_number == winning_card$win_card) %&gt;% 
  select(-card_number) %&gt;% 
  mutate(across(everything(), ~as.numeric(.))) %&gt;% 
  as.matrix() %&gt;% sum(na.rm = T) %&gt;% prod(as.numeric(winning_card$selection))</code></pre>
</div>
<div id="part-2-6" class="section level4">
<h4>Part 2</h4>
<pre class="r"><code>boards_list &lt;- list(boards = boards)

mark_board_2 &lt;- function(boards_list = boards_list, selection = selections[41]){

  if(max(boards_list$boards$winner)==100){stop(boards_list)}
  
  boards &lt;- boards_list$boards
  
  marked &lt;-
    boards %&gt;% 
    mutate(across(.cols = 1:5, .fns = ~str_replace_all(string = ., pattern = selection, replacement = &quot;X&quot;)))
  
  row_win_card &lt;-
    marked %&gt;%
    mutate(row_bingo = str_count(str_c(V1,V2,V3,V4,V5),&quot;X&quot;)) %&gt;% 
    filter(row_bingo==5)  %&gt;% 
    pull(card_number)
  
  col_win_card &lt;-
    marked %&gt;% 
    mutate(across(.cols = V1:V5, .fns = ~ifelse(.==&quot;X&quot;,1,0))) %&gt;% 
    group_by(card_number) %&gt;% 
    summarise(across(everything(), ~sum(.))) %&gt;% 
    filter(V1 ==5|V2 ==5|V3 ==5|V4 ==5|V5 ==5) %&gt;% 
    pull(card_number)
  
  if(length(row_win_card)&gt;0 &amp; nrow(marked) == 5){
    marked &lt;- 
      marked %&gt;% 
      mutate(winner = 100)
    return(out &lt;- list(boards = marked, selection = selection))
    } else if(length(row_win_card)&gt;0){
    marked &lt;- 
    marked %&gt;% 
      filter(!card_number %in% row_win_card)
  }
  if(length(col_win_card)&gt;0 &amp; nrow(marked) == 5){
    marked &lt;- 
    marked %&gt;% 
      mutate(winner = 100)
    return(out &lt;- list(boards = marked, selection = selection))
  } else if(length(col_win_card)&gt;0){
    marked &lt;- 
    marked %&gt;% 
      filter(!card_number %in% col_win_card)
  }
  
  out &lt;- list(boards = marked, selection = selection)
  
  return(out)
  
}

mark_board_2_poss &lt;- possibly(mark_board_2, otherwise = NULL)

winning_card &lt;-
selections %&gt;% 
  accumulate(mark_board_2_poss, .init = boards_list) %&gt;% 
  discard(is.null) %&gt;% 
  pluck(length(.))

winning_card$boards %&gt;% 
  select(V1:V5) %&gt;% 
  mutate(across(everything(), ~as.numeric(.))) %&gt;% 
  as.matrix() %&gt;% sum(na.rm = T) %&gt;% prod(as.numeric(winning_card$selection))</code></pre>
</div>
</div>
<div id="day-3" class="section level2">
<h2><a href="https://adventofcode.com/2021/day/3">Day 3</a></h2>
<p>I rely on several pivots, <code>unite()</code>, and the iterative function <code>purrr::reduce()</code> for this problem.</p>
<div id="part-1-8" class="section level4">
<h4>Part 1</h4>
<pre class="r"><code>tibble(binary = read_lines(&quot;day_3.txt&quot;)) %&gt;% 
  transmute(col = str_split_fixed(binary, pattern = &quot;&quot;, n = nchar(binary))) %&gt;% 
  pull(col) %&gt;% as_tibble() %&gt;% 
  summarise(across(.cols = everything(), .fns = ~if_else(mean(as.numeric(.))&gt;.5,1,0))) %&gt;% 
  pivot_longer(cols = everything(), values_to = &quot;gamma&quot;, names_to = &quot;slot&quot;)  %&gt;% 
  mutate(epsilon = if_else(gamma == 1, 0, 1)) %&gt;% 
  pivot_longer(cols = -slot) %&gt;% 
  pivot_wider(names_from = slot, values_from = value) %&gt;% 
  unite(col = &quot;binary&quot;,  where(is.double), sep = &quot;&quot;)  %&gt;% 
  mutate(decimal = strtoi(as.double(binary), base = 2)) %&gt;% 
  pull(decimal) %&gt;% prod()</code></pre>
</div>
<div id="part-2-7" class="section level4">
<h4>Part 2</h4>
<pre class="r"><code>data &lt;-
tibble(binary = read_lines(&quot;day_3.txt&quot;)) %&gt;% 
  transmute(col = str_split_fixed(binary, pattern = &quot;&quot;, n = nchar(binary))) %&gt;% 
  pull(col) %&gt;% as_tibble() %&gt;% 
  summarise(across(.cols = everything(), .fns = ~as.numeric(.))) 

filter_rating &lt;- function(data, col = &quot;V1&quot;, type = &quot;oxygen&quot;){
  if(nrow(data)==1){out &lt;- data} 
  else if(type == &quot;oxygen&quot;){out &lt;- data[data[,col]==if_else(mean(data[,col][[1]])&gt;=.5,1,0),]}
  else if(type == &quot;co2&quot;){out &lt;- data[data[,col]==if_else(mean(data[,col][[1]])&lt;.5,1,0),]}
}
  
reduce(.x = names(data), .f = filter_rating, .init = data, &quot;oxygen&quot;) %&gt;%
  unite(col = &quot;binary&quot;,everything(), sep = &quot;&quot;) %&gt;% 
  pull() %&gt;% strtoi(base = 2) *

reduce(.x = names(data), .f = filter_rating, .init = data, &quot;co2&quot;) %&gt;%
  unite(col = &quot;binary&quot;,everything(), sep = &quot;&quot;) %&gt;% 
  pull() %&gt;% strtoi(base = 2)</code></pre>
</div>
</div>
<div id="day-2" class="section level2">
<h2><a href="https://adventofcode.com/2021/day/2">Day 2</a></h2>
<p>Today I used <code>seperate()</code> and <code>cumsum()</code> to work this problem.</p>
<div id="part-1-9" class="section level4">
<h4>Part 1</h4>
<pre class="r"><code>tibble(x = read_lines(&quot;day_2.txt&quot;)) %&gt;% 
  separate(col = x, into = c(&quot;direction&quot;,&quot;distance&quot;), convert = TRUE) %&gt;% 
  group_by(real_direction = direction == &quot;forward&quot;) %&gt;% 
  mutate(distance = ifelse(direction == &quot;up&quot;, distance * -1, distance)) %&gt;% 
  summarise(movement = sum(distance)) %&gt;% 
  pull(movement) %&gt;% prod()</code></pre>
</div>
<div id="part-2-8" class="section level4">
<h4>Part 2</h4>
<pre class="r"><code>tibble(x = read_lines(&quot;day_2.txt&quot;)) %&gt;% 
  separate(col = x, into = c(&quot;direction&quot;,&quot;distance&quot;), convert = TRUE) %&gt;%
  mutate(distance = as.double(distance)) %&gt;% 
  mutate(aim_change = case_when(direction == &quot;forward&quot; ~ 0,
                                direction == &quot;down&quot; ~ distance,
                                direction == &quot;up&quot; ~ -1 * distance)) %&gt;% 
  mutate(aim = cumsum(aim_change)) %&gt;% 
  mutate(horizontal_position_increase = ifelse(direction == &quot;forward&quot;, distance, 0)) %&gt;% 
  mutate(depth_position_increase = ifelse(direction == &quot;forward&quot;, aim * distance,0)) %&gt;% 
  mutate(horizontal_position = cumsum(horizontal_position_increase)) %&gt;% 
  mutate(depth_position = cumsum(depth_position_increase)) %&gt;% 
  slice_tail(n = 1) %&gt;% 
  summarise(answer = horizontal_position * depth_position) </code></pre>
</div>
<div id="day-1" class="section level3">
<h3><a href="https://adventofcode.com/2021/day/1">Day 1</a></h3>
<p>Using <code>lag()</code> and <code>zoo::rollsum()</code> we are able to accomplish day one pretty easily.</p>
<div id="part-1-10" class="section level4">
<h4>Part 1</h4>
<pre class="r"><code>tibble(measurements = as.numeric(read_lines(&quot;day1.txt&quot;))) %&gt;%  
  filter(measurements &gt; lag(measurements,1)) %&gt;% 
  nrow()</code></pre>
</div>
<div id="part-2-9" class="section level4">
<h4>Part 2</h4>
<pre class="r"><code>tibble(measurements = as.numeric(read_lines(&quot;day1.txt&quot;))) %&gt;%
  mutate(roll_sum = zoo::rollsum(measurements,3, fill = NA, align = &quot;right&quot;)) %&gt;%
  filter(roll_sum &gt; lag(roll_sum,1)) %&gt;%
  nrow()</code></pre>
</div>
</div>
</div>
