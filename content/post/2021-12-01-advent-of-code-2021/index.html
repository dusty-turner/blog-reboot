---
title: Advent of Code 2021
author: Dusty Turner
date: '2021-12-01'
slug: []
categories:
  - R
  - datascience
  - learning
  - teaching
tags:
  - R
  - Data Science
  - learning
  - teaching
cover: /media/advent2.JPG
---

<script src="{{< blogdown/postref >}}index_files/header-attrs/header-attrs.js"></script>


<p>Every year, the great team at <a href="adventofcode.com">Advent of Code</a> lead by <a href="https://twitter.com/ericwastl">ericwastl</a> develops an “Advent calendar of small programming puzzles for a variety of skill sets and skill levels that can be solved in any programming language you like.”</p>
<p>Well, I like R, so in this post I will provide my solutions to the puzzles each day. I plan on using this post to learn and teach and hopefully I am able to stay up-to-date!</p>
<p>A few notes as we get started:</p>
<ul>
<li>Unless otherwise specified, all solutions rely on <code>library(tidyverse)</code>.</li>
<li>All data is saved in the working directory as a <code>.txt</code> file.</li>
<li>I can’t promise my solutions will be the most elegant, but I will only post if they are correct!</li>
</ul>
<p>On to the solutions…</p>
<div id="code-supporting-all-solutions" class="section level4">
<h4>Code supporting all solutions</h4>
<pre class="r"><code>library(tidyverse)</code></pre>
</div>
<div id="day-5" class="section level2">
<h2><a href="https://adventofcode.com/2021/day/5">Day 5</a></h2>
<div id="part-1" class="section level4">
<h4>Part 1</h4>
<!-- For this problem, I created a matrix to track the lines of the hydrothermic vents. In part one, each line was straight so I was able to build this matrix fairly simply.  I had to create a toggle for vents that were horizontal vs vertical. -->
<pre class="r"><code>movements &lt;-
  tibble(directions = read_lines(&quot;02_data/day_5.txt&quot;)) %&gt;%
  mutate(directions = str_replace_all(string = directions, pattern = &quot; -&gt; &quot;, &quot;,&quot;)) %&gt;% 
  separate(col = directions, into = c(&quot;x1&quot;, &quot;y1&quot;, &quot;x2&quot;, &quot;y2&quot;), sep = &quot;,&quot;, convert = T) %&gt;% 
  select(x1,x2,y1,y2) 

create_lines &lt;- function(move){

if(move$y1==move$y2) {
  xlow  &lt;- min(move$x1, min(move$x2))
  xhigh &lt;- max(move$x1, min(move$x2))
  ylow  &lt;- min(move$y1, min(move$y2))
  yhigh &lt;- max(move$y1, min(move$y2))
  byrow &lt;- T # for horizontal vents
} else if (move$x1 == move$x2) {
  ylow  &lt;- min(move$x1, min(move$x2))
  yhigh &lt;- max(move$x1, min(move$x2))
  xlow  &lt;- min(move$y1, min(move$y2))
  xhigh &lt;- max(move$y1, min(move$y2))
  byrow &lt;- F # for vertical vents
}
out &lt;- matrix(c(
  rep(rep(0,1000),ylow), ## zeroes before row/col
  c(rep(0,xlow),rep(1,xhigh-xlow+1), rep(0,999-xhigh)), ## row/col of 1s
  rep(rep(0,1000),999-ylow) ## zeroes after row/col
  ), byrow = byrow, nrow = 1000, ncol = 1000)
return(out)
}

movements %&gt;% 
  filter(x1==x2 | y1==y2) %&gt;% 
  group_split(row_number(), .keep = F) %&gt;% 
  purrr::map(~create_lines(lines = .x)) %&gt;% 
  reduce(`+`) %&gt;% as_tibble() %&gt;% 
  pivot_longer(cols = everything()) %&gt;% 
  filter(value &gt;=2) %&gt;% 
  count()</code></pre>
</div>
<div id="part-2" class="section level4">
<h4>Part 2</h4>
<!-- In this part some of the vents were diagonal.  I used the first function to mark the straight vents and created a second function to trace the ones at an angle.  I had to condition this off the top right to bottom left lines verses the top left to bottom right lines.  -->
<pre class="r"><code>cross_routes &lt;- function(move){

  xlow  &lt;- min(move$x1, min(move$x2))
  xhigh &lt;- max(move$x1, min(move$x2))
  ylow  &lt;- min(move$y1, min(move$y2))
  yhigh &lt;- max(move$y1, min(move$y2))

mat &lt;- matrix(rep(0,1000000), ncol = 1000) # create a 1000 x 1000 matrix
if((move$x2&gt;move$x1 &amp; move$y2&gt;move$y1) | (move$x2&lt;move$x1 &amp; move$y2&lt;move$y1)){
  for (i in 1:length(xlow:xhigh)) {
    mat[ylow+i,xlow+i] &lt;- 1
  }
} else{ ## vent is top left to bottom right
  for (i in 1:length(xlow:xhigh)) {
    mat[ylow+i,xhigh+2-i] &lt;- 1
  }
}## determine if vent is top right to bottom left
return(mat)
}

striaght_lines &lt;- # from part 1
  movements %&gt;% 
  filter(x1==x2 | y1==y2) %&gt;% # straight lines
  group_split(row_number(), .keep = F) %&gt;% 
  purrr::map(~create_lines(lines = .x)) %&gt;% 
  reduce(`+`) 

diagonal_lines &lt;-
  movements %&gt;%
  filter(x1!=x2 &amp; y1!=y2) %&gt;% # diagonal lines
  group_split(row_number(), .keep = F) %&gt;% 
  purrr::map(~cross_routes(move = .x)) %&gt;% 
  reduce(`+`) 
 
as_tibble(striaght_lines + diagonal_lines) %&gt;% 
  pivot_longer(cols = everything()) %&gt;%
  filter(value &gt;=2) %&gt;%
  count()</code></pre>
</div>
</div>
<div id="day-4" class="section level2">
<h2><a href="https://adventofcode.com/2021/day/4">Day 4</a></h2>
<p>I feel like this could be done more simply, but today I create a function that take the bingo number, adjudicates each board, determines if there is a winner, then outputs the next board. Then we use <code>purrr::accumulate()</code> and <code>purrr::possibly()</code> to handle errors that I intentionally create.</p>
<div id="part-1-1" class="section level4">
<h4>Part 1</h4>
<pre class="r"><code>data &lt;- read_lines(&quot;day_4.txt&quot;)

selections &lt;-
  data[1] %&gt;% str_split(&quot;,&quot;) %&gt;% unlist() %&gt;% str_pad(2,&quot;left&quot;) %&gt;% str_pad(3,&quot;right&quot;)

boards &lt;-
  tibble(cards = data[-1]) %&gt;% 
  filter(cards != &quot;&quot;) %&gt;%
  mutate(cards = str_squish(cards)) %&gt;% 
  transmute(col = str_split_fixed(cards, pattern = &quot; &quot;, n = 5)) %&gt;% 
  pull(col) %&gt;% as_tibble() %&gt;% 
  mutate(across(.cols = everything(),.fns = ~str_pad(str_pad(.,2,&quot;left&quot;),3,&quot;right&quot;))) %&gt;% 
  mutate(card_number = sort(rep(1:(n()/5),5))) %&gt;% 
  mutate(winner = 0)

boards_list &lt;- list(boards = boards, win_card = integer(0))

mark_board &lt;- function(boards_list = boards_list, selection = selections[1]){
  if(length(boards_list$win_card) &gt; 0){stop(boards_list)}
  boards &lt;- boards_list$boards
  marked &lt;-
    boards %&gt;% 
    mutate(across(.cols = 1:5, .fns = ~str_replace_all(string = ., pattern = selection, replacement = &quot;X&quot;)))
  row_win_card &lt;-
    marked %&gt;%
    mutate(row_bingo = str_count(str_c(V1,V2,V3,V4,V5),&quot;X&quot;)) %&gt;% 
    filter(row_bingo==5)  %&gt;% 
    pull(card_number)
  col_win_card &lt;-
    marked %&gt;% 
    mutate(across(.cols = V1:V5, .fns = ~ifelse(.==&quot;X&quot;,1,0))) %&gt;% 
    group_by(card_number) %&gt;% 
    summarise(across(everything(), ~sum(.))) %&gt;% 
    filter(V1 ==5|V2 ==5|V3 ==5|V4 ==5|V5 ==5) %&gt;% 
    pull(card_number)
  card_number &lt;- ifelse(length(row_win_card) &gt; 0, row_win_card, ifelse(length(col_win_card) &gt; 0, col_win_card, integer(0)))
  if(is.na(card_number)){card_number &lt;- integer(0)}
  out &lt;- list(boards = marked, win_card = card_number, selection = selection)
  return(out)
}

mark_board_poss &lt;- possibly(mark_board, otherwise = NULL)

winning_card &lt;- 
selections %&gt;% 
  accumulate(.f = mark_board_poss, .init = boards_list) %&gt;% 
  discard(is.null) %&gt;% 
  pluck(length(.)) 

winning_card$boards %&gt;% 
  filter(card_number == winning_card$win_card) %&gt;% 
  select(-card_number) %&gt;% 
  mutate(across(everything(), ~as.numeric(.))) %&gt;% 
  as.matrix() %&gt;% sum(na.rm = T) %&gt;% prod(as.numeric(winning_card$selection))</code></pre>
</div>
<div id="part-2-1" class="section level4">
<h4>Part 2</h4>
<pre class="r"><code>boards_list &lt;- list(boards = boards)

mark_board_2 &lt;- function(boards_list = boards_list, selection = selections[41]){

  if(max(boards_list$boards$winner)==100){stop(boards_list)}
  
  boards &lt;- boards_list$boards
  
  marked &lt;-
    boards %&gt;% 
    mutate(across(.cols = 1:5, .fns = ~str_replace_all(string = ., pattern = selection, replacement = &quot;X&quot;)))
  
  row_win_card &lt;-
    marked %&gt;%
    mutate(row_bingo = str_count(str_c(V1,V2,V3,V4,V5),&quot;X&quot;)) %&gt;% 
    filter(row_bingo==5)  %&gt;% 
    pull(card_number)
  
  col_win_card &lt;-
    marked %&gt;% 
    mutate(across(.cols = V1:V5, .fns = ~ifelse(.==&quot;X&quot;,1,0))) %&gt;% 
    group_by(card_number) %&gt;% 
    summarise(across(everything(), ~sum(.))) %&gt;% 
    filter(V1 ==5|V2 ==5|V3 ==5|V4 ==5|V5 ==5) %&gt;% 
    pull(card_number)
  
  if(length(row_win_card)&gt;0 &amp; nrow(marked) == 5){
    marked &lt;- 
      marked %&gt;% 
      mutate(winner = 100)
    return(out &lt;- list(boards = marked, selection = selection))
    } else if(length(row_win_card)&gt;0){
    marked &lt;- 
    marked %&gt;% 
      filter(!card_number %in% row_win_card)
  }
  if(length(col_win_card)&gt;0 &amp; nrow(marked) == 5){
    marked &lt;- 
    marked %&gt;% 
      mutate(winner = 100)
    return(out &lt;- list(boards = marked, selection = selection))
  } else if(length(col_win_card)&gt;0){
    marked &lt;- 
    marked %&gt;% 
      filter(!card_number %in% col_win_card)
  }
  
  out &lt;- list(boards = marked, selection = selection)
  
  return(out)
  
}

mark_board_2_poss &lt;- possibly(mark_board_2, otherwise = NULL)

winning_card &lt;-
selections %&gt;% 
  accumulate(mark_board_2_poss, .init = boards_list) %&gt;% 
  discard(is.null) %&gt;% 
  pluck(length(.))

winning_card$boards %&gt;% 
  select(V1:V5) %&gt;% 
  mutate(across(everything(), ~as.numeric(.))) %&gt;% 
  as.matrix() %&gt;% sum(na.rm = T) %&gt;% prod(as.numeric(winning_card$selection))</code></pre>
</div>
</div>
<div id="day-3" class="section level2">
<h2><a href="https://adventofcode.com/2021/day/3">Day 3</a></h2>
<p>I rely on several pivots, <code>unite()</code>, and the iterative function <code>purrr::reduce()</code> for this problem.</p>
<div id="part-1-2" class="section level4">
<h4>Part 1</h4>
<pre class="r"><code>tibble(binary = read_lines(&quot;day_3.txt&quot;)) %&gt;% 
  transmute(col = str_split_fixed(binary, pattern = &quot;&quot;, n = nchar(binary))) %&gt;% 
  pull(col) %&gt;% as_tibble() %&gt;% 
  summarise(across(.cols = everything(), .fns = ~if_else(mean(as.numeric(.))&gt;.5,1,0))) %&gt;% 
  pivot_longer(cols = everything(), values_to = &quot;gamma&quot;, names_to = &quot;slot&quot;)  %&gt;% 
  mutate(epsilon = if_else(gamma == 1, 0, 1)) %&gt;% 
  pivot_longer(cols = -slot) %&gt;% 
  pivot_wider(names_from = slot, values_from = value) %&gt;% 
  unite(col = &quot;binary&quot;,  where(is.double), sep = &quot;&quot;)  %&gt;% 
  mutate(decimal = strtoi(as.double(binary), base = 2)) %&gt;% 
  pull(decimal) %&gt;% prod()</code></pre>
</div>
<div id="part-2-2" class="section level4">
<h4>Part 2</h4>
<pre class="r"><code>data &lt;-
tibble(binary = read_lines(&quot;day_3.txt&quot;)) %&gt;% 
  transmute(col = str_split_fixed(binary, pattern = &quot;&quot;, n = nchar(binary))) %&gt;% 
  pull(col) %&gt;% as_tibble() %&gt;% 
  summarise(across(.cols = everything(), .fns = ~as.numeric(.))) 

filter_rating &lt;- function(data, col = &quot;V1&quot;, type = &quot;oxygen&quot;){
  if(nrow(data)==1){out &lt;- data} 
  else if(type == &quot;oxygen&quot;){out &lt;- data[data[,col]==if_else(mean(data[,col][[1]])&gt;=.5,1,0),]}
  else if(type == &quot;co2&quot;){out &lt;- data[data[,col]==if_else(mean(data[,col][[1]])&lt;.5,1,0),]}
}
  
reduce(.x = names(data), .f = filter_rating, .init = data, &quot;oxygen&quot;) %&gt;%
  unite(col = &quot;binary&quot;,everything(), sep = &quot;&quot;) %&gt;% 
  pull() %&gt;% strtoi(base = 2) *

reduce(.x = names(data), .f = filter_rating, .init = data, &quot;co2&quot;) %&gt;%
  unite(col = &quot;binary&quot;,everything(), sep = &quot;&quot;) %&gt;% 
  pull() %&gt;% strtoi(base = 2)</code></pre>
</div>
</div>
<div id="day-2" class="section level2">
<h2><a href="https://adventofcode.com/2021/day/2">Day 2</a></h2>
<p>Today I used <code>seperate()</code> and <code>cumsum()</code> to work this problem.</p>
<div id="part-1-3" class="section level4">
<h4>Part 1</h4>
<pre class="r"><code>tibble(x = read_lines(&quot;day_2.txt&quot;)) %&gt;% 
  separate(col = x, into = c(&quot;direction&quot;,&quot;distance&quot;), convert = TRUE) %&gt;% 
  group_by(real_direction = direction == &quot;forward&quot;) %&gt;% 
  mutate(distance = ifelse(direction == &quot;up&quot;, distance * -1, distance)) %&gt;% 
  summarise(movement = sum(distance)) %&gt;% 
  pull(movement) %&gt;% prod()</code></pre>
</div>
<div id="part-2-3" class="section level4">
<h4>Part 2</h4>
<pre class="r"><code>tibble(x = read_lines(&quot;day_2.txt&quot;)) %&gt;% 
  separate(col = x, into = c(&quot;direction&quot;,&quot;distance&quot;), convert = TRUE) %&gt;%
  mutate(distance = as.double(distance)) %&gt;% 
  mutate(aim_change = case_when(direction == &quot;forward&quot; ~ 0,
                                direction == &quot;down&quot; ~ distance,
                                direction == &quot;up&quot; ~ -1 * distance)) %&gt;% 
  mutate(aim = cumsum(aim_change)) %&gt;% 
  mutate(horizontal_position_increase = ifelse(direction == &quot;forward&quot;, distance, 0)) %&gt;% 
  mutate(depth_position_increase = ifelse(direction == &quot;forward&quot;, aim * distance,0)) %&gt;% 
  mutate(horizontal_position = cumsum(horizontal_position_increase)) %&gt;% 
  mutate(depth_position = cumsum(depth_position_increase)) %&gt;% 
  slice_tail(n = 1) %&gt;% 
  summarise(answer = horizontal_position * depth_position) </code></pre>
</div>
<div id="day-1" class="section level3">
<h3><a href="https://adventofcode.com/2021/day/1">Day 1</a></h3>
<p>Using <code>lag()</code> and <code>zoo::rollsum()</code> we are able to accomplish day one pretty easily.</p>
<div id="part-1-4" class="section level4">
<h4>Part 1</h4>
<pre class="r"><code>tibble(measurements = as.numeric(read_lines(&quot;day1.txt&quot;))) %&gt;%  
  filter(measurements &gt; lag(measurements,1)) %&gt;% 
  nrow()</code></pre>
</div>
<div id="part-2-4" class="section level4">
<h4>Part 2</h4>
<pre class="r"><code>tibble(measurements = as.numeric(read_lines(&quot;day1.txt&quot;))) %&gt;%
  mutate(roll_sum = zoo::rollsum(measurements,3, fill = NA, align = &quot;right&quot;)) %&gt;%
  filter(roll_sum &gt; lag(roll_sum,1)) %&gt;%
  nrow()</code></pre>
</div>
</div>
</div>
