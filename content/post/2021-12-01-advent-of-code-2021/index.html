---
title: Advent of Code 2021
author: Dusty Turner
date: '2021-12-01'
slug: []
categories:
  - R
  - datascience
  - learning
  - teaching
tags:
  - R
  - Data Science
  - learning
  - teaching
cover: /media/advent2.JPG
---

<script src="{{< blogdown/postref >}}index_files/header-attrs/header-attrs.js"></script>


<p>Every year, the great team at <a href="adventofcode.com">Advent of Code</a> lead by <a href="https://twitter.com/ericwastl">ericwastl</a> develops an “Advent calendar of small programming puzzles for a variety of skill sets and skill levels that can be solved in any programming language you like.”</p>
<p>Well, I like R, so in this post I will provide my solutions to the puzzles each day. I plan on using this post to learn and teach and hopefully I am able to stay up-to-date!</p>
<p>A few notes as we get started:</p>
<ul>
<li>Unless otherwise specified, all solutions rely on <code>library(tidyverse)</code>.</li>
<li>All data is saved in the working directory as a <code>.txt</code> file.</li>
<li>I can’t promise my solutions will be the most elegant, but I will only post if they are correct!</li>
</ul>
<p>On to the solutions…</p>
<div id="code-supporting-all-solutions" class="section level4">
<h4>Code supporting all solutions</h4>
<pre class="r"><code>library(tidyverse)</code></pre>
</div>
<div id="day-7" class="section level2">
<h2><a href="https://adventofcode.com/2021/day/7">Day 7</a></h2>
<div id="part-1" class="section level4">
<h4>Part 1</h4>
<p>To solve part 1, I create a function that finds the distance between all points to a specific point, map across all specific points, and then find the minimum distance.</p>
<!-- dat <- read_lines("content/post/2021-12-01-advent-of-code-2021/day_7.txt") %>% str_split(",") %>% unlist() %>% as.numeric() -->
<pre class="r"><code>dat &lt;- as.numeric(unlist(str_split(read_lines(&quot;02_data/day_7.txt&quot;),&quot;,&quot;))) 

distance &lt;- function(data = dat, position) {
  out &lt;- sum(abs(data - position))
  return(out)
}

min(dat):max(dat) %&gt;% 
  map_dbl(.f = ~distance(data = dat, position = .x)) %&gt;% min()</code></pre>
</div>
<div id="part-2" class="section level4">
<h4>Part 2</h4>
<p>I alter the distance formula to find the triangular number between two numbers. This can also be factored into the binomial coefficient with the upper index being the distance between the numbers and 2 as the lower index.</p>
<pre class="r"><code>distance_plus &lt;- function(data = dat, position) {
  n &lt;-abs(data-position)+1
  out &lt;- sum(choose(n,2))
  return(out)
}

min(dat):max(dat) %&gt;% 
  map_dbl(.f = ~distance_plus(data = dat, position = .x)) %&gt;% min()</code></pre>
</div>
<div id="code-golfing" class="section level4">
<h4>Code Golfing</h4>
<p>This last code chunk is my attempt at ‘code golfing’ - aka - how succinct can I make my code. I can answer both parts with fairly brief code, but I think its less understandable.</p>
<pre class="r"><code>fuel_calculation &lt;- function(data = dat, position, type) {
  if(type == &quot;distance&quot;){out &lt;- tibble(fuel = sum(abs(data - position)), position = position, type)}
  if(type == &quot;triangular&quot;){out &lt;- tibble(fuel = sum(choose(abs(data-position)+1,2)), position = position, type)}
  return(out)
}

rep(min(dat):max(dat), 2) %&gt;%
  map2_dfr(.y = c(rep(&quot;distance&quot;, length(min(dat):max(dat))), rep(&quot;triangular&quot;, length(min(dat):max(dat)))),
    .f = ~ fuel_calculation(data = dat,position = .x, type = .y)) %&gt;%
  group_split(type) %&gt;%
  map( ~ filter(.x, fuel == min(fuel)))</code></pre>
</div>
</div>
<div id="day-6" class="section level2">
<h2><a href="https://adventofcode.com/2021/day/6">Day 6</a></h2>
<div id="part-1-and-2" class="section level4">
<h4>Part 1 and 2</h4>
<p>My gut instinct is to always think in ‘tidy’ coding concepts. This will get the answer, but when moving from part 1 to part 2, the time it takes to run the code becomes computationally infeasible with my computer. I’ll show my 3 attempts.</p>
</div>
<div id="strike-1" class="section level4">
<h4>Strike 1</h4>
<pre class="r"><code>initial_fish &lt;- tibble(fish = read_lines(&quot;day_6.txt&quot;)) %&gt;%
  separate_rows(fish, sep = &quot;,&quot;, convert = T) 

progress_day &lt;- function(fish = initial_fish, after_day = 1){
fish &lt;-
  fish %&gt;% 
  mutate(fish = ifelse(fish &lt;= 0 , &quot;6,8&quot;, fish-1)) %&gt;% 
  separate_rows(fish, sep = &quot;,&quot;, convert = T) 
return(fish)
}

tictoc::tic()
ans &lt;- 1:80 %&gt;% 
# ans &lt;- 1:256 %&gt;% nope!
  reduce(.f = progress_day, .init = initial_fish) %&gt;% nrow()
tictoc::toc()</code></pre>
<pre><code>## 38.55 sec elapsed</code></pre>
<p>My second attempt was a ‘non-tidy’ solution, but part 2 also took too long to run.</p>
</div>
<div id="strike-2" class="section level4">
<h4>Strike 2</h4>
<pre class="r"><code>initial_fish &lt;- as.numeric(unlist(strsplit(readr::read_lines(&quot;day_6.txt&quot;),&quot;,&quot;)))

progress_day &lt;- function(fish = initial_fish, after_day = 1) {
  
  add_fish &lt;- sum(fish == 0)
  next_day &lt;- fish - 1
  next_day[next_day &lt; 0] &lt;- 6

  out &lt;- c(next_day, rep(8, add_fish))
return(out)  
}

tictoc::tic()
ans &lt;- 1:150 %&gt;% 
# ans &lt;- 1:256 %&gt;% faster, but nope! 
  reduce(.f = progress_day, .init = initial_fish) %&gt;% length()
tictoc::toc() </code></pre>
<pre><code>## 36.25 sec elapsed</code></pre>
<p>Lastly, instead of building out a vector for each fish, I decided to count the number of fish at each state of their birthing countdown. This make things work nice and quick.</p>
</div>
<div id="success" class="section level4">
<h4>Success!</h4>
<pre class="r"><code>fish &lt;- as.numeric(unlist(strsplit(read_lines(&quot;day_6.txt&quot;),&quot;,&quot;)))
 
initial_fish &lt;- c(
length(fish[fish==8]),
length(fish[fish==7]),
length(fish[fish==6]),
length(fish[fish==5]),
length(fish[fish==4]),
length(fish[fish==3]),
length(fish[fish==2]),
length(fish[fish==1]),
length(fish[fish==0]))

progress_day &lt;- function(fish = initial_fish, after_day = 1){

births = fish[9]
get_older &lt;- replace_na(lag(fish),0)
out &lt;- c(births, get_older[2], get_older[3]+births, get_older[-c(1:3)])
return(out)
}

tictoc::tic()
ans &lt;- 1:256 %&gt;% 
  reduce(.f = progress_day, .init = initial_fish) %&gt;% sum()
tictoc::toc()</code></pre>
<pre><code>## 0.01 sec elapsed</code></pre>
</div>
</div>
<div id="day-5" class="section level2">
<h2><a href="https://adventofcode.com/2021/day/5">Day 5</a></h2>
<div id="part-1-1" class="section level4">
<h4>Part 1</h4>
<p>For this problem, I created a matrix to track the lines of the hydrothermic vents. In part one, each line was straight so I was able to build this matrix fairly simply. I had to create a toggle for vents that were horizontal vs vertical.</p>
<pre class="r"><code>movements &lt;-
  tibble(directions = read_lines(&quot;day_5.txt&quot;)) %&gt;%
  mutate(directions = str_replace_all(string = directions, pattern = &quot; -&gt; &quot;, &quot;,&quot;)) %&gt;% 
  separate(col = directions, into = c(&quot;x1&quot;, &quot;y1&quot;, &quot;x2&quot;, &quot;y2&quot;), sep = &quot;,&quot;, convert = T) %&gt;% 
  select(x1,x2,y1,y2) 

create_lines &lt;- function(move){

if(move$y1==move$y2) {
  xlow  &lt;- min(move$x1, min(move$x2))
  xhigh &lt;- max(move$x1, min(move$x2))
  ylow  &lt;- min(move$y1, min(move$y2))
  yhigh &lt;- max(move$y1, min(move$y2))
  byrow &lt;- T # for horizontal vents
} else if (move$x1 == move$x2) {
  ylow  &lt;- min(move$x1, min(move$x2))
  yhigh &lt;- max(move$x1, min(move$x2))
  xlow  &lt;- min(move$y1, min(move$y2))
  xhigh &lt;- max(move$y1, min(move$y2))
  byrow &lt;- F # for vertical vents
}
out &lt;- matrix(c(
  rep(rep(0,1000),ylow), ## zeroes before row/col
  c(rep(0,xlow),rep(1,xhigh-xlow+1), rep(0,999-xhigh)), ## row/col of 1s
  rep(rep(0,1000),999-ylow) ## zeroes after row/col
  ), byrow = byrow, nrow = 1000, ncol = 1000)
return(out)
}

movements %&gt;% 
  filter(x1==x2 | y1==y2) %&gt;% 
  group_split(row_number(), .keep = F) %&gt;% 
  purrr::map(~create_lines(lines = .x)) %&gt;% 
  reduce(`+`) %&gt;% as_tibble() %&gt;% 
  pivot_longer(cols = everything()) %&gt;% 
  filter(value &gt;=2) %&gt;% 
  count()</code></pre>
</div>
<div id="part-2-1" class="section level4">
<h4>Part 2</h4>
<p>In this part some of the vents were diagonal. I used the first function to mark the straight vents and created a second function to trace the ones at an angle. I had to condition this off the top right to bottom left lines verses the top left to bottom right lines.</p>
<pre class="r"><code>cross_routes &lt;- function(move){

  xlow  &lt;- min(move$x1, min(move$x2))
  xhigh &lt;- max(move$x1, min(move$x2))
  ylow  &lt;- min(move$y1, min(move$y2))
  yhigh &lt;- max(move$y1, min(move$y2))

mat &lt;- matrix(rep(0,1000000), ncol = 1000) # create a 1000 x 1000 matrix
if((move$x2&gt;move$x1 &amp; move$y2&gt;move$y1) | (move$x2&lt;move$x1 &amp; move$y2&lt;move$y1)){
  for (i in 1:length(xlow:xhigh)) {
    mat[ylow+i,xlow+i] &lt;- 1
  }
} else{ ## vent is top left to bottom right
  for (i in 1:length(xlow:xhigh)) {
    mat[ylow+i,xhigh+2-i] &lt;- 1
  }
}## determine if vent is top right to bottom left
return(mat)
}

striaght_lines &lt;- # from part 1
  movements %&gt;% 
  filter(x1==x2 | y1==y2) %&gt;% # straight lines
  group_split(row_number(), .keep = F) %&gt;% 
  purrr::map(~create_lines(lines = .x)) %&gt;% 
  reduce(`+`) 

diagonal_lines &lt;-
  movements %&gt;%
  filter(x1!=x2 &amp; y1!=y2) %&gt;% # diagonal lines
  group_split(row_number(), .keep = F) %&gt;% 
  purrr::map(~cross_routes(move = .x)) %&gt;% 
  reduce(`+`) 
 
as_tibble(striaght_lines + diagonal_lines) %&gt;% 
  pivot_longer(cols = everything()) %&gt;%
  filter(value &gt;=2) %&gt;%
  count()</code></pre>
</div>
</div>
<div id="day-4" class="section level2">
<h2><a href="https://adventofcode.com/2021/day/4">Day 4</a></h2>
<p>I feel like this could be done more simply, but today I create a function that take the bingo number, adjudicates each board, determines if there is a winner, then outputs the next board. Then we use <code>purrr::accumulate()</code> and <code>purrr::possibly()</code> to handle errors that I intentionally create.</p>
<div id="part-1-2" class="section level4">
<h4>Part 1</h4>
<pre class="r"><code>data &lt;- read_lines(&quot;day_4.txt&quot;)

selections &lt;-
  data[1] %&gt;% str_split(&quot;,&quot;) %&gt;% unlist() %&gt;% str_pad(2,&quot;left&quot;) %&gt;% str_pad(3,&quot;right&quot;)

boards &lt;-
  tibble(cards = data[-1]) %&gt;% 
  filter(cards != &quot;&quot;) %&gt;%
  mutate(cards = str_squish(cards)) %&gt;% 
  transmute(col = str_split_fixed(cards, pattern = &quot; &quot;, n = 5)) %&gt;% 
  pull(col) %&gt;% as_tibble() %&gt;% 
  mutate(across(.cols = everything(),.fns = ~str_pad(str_pad(.,2,&quot;left&quot;),3,&quot;right&quot;))) %&gt;% 
  mutate(card_number = sort(rep(1:(n()/5),5))) %&gt;% 
  mutate(winner = 0)

boards_list &lt;- list(boards = boards, win_card = integer(0))

mark_board &lt;- function(boards_list = boards_list, selection = selections[1]){
  if(length(boards_list$win_card) &gt; 0){stop(boards_list)}
  boards &lt;- boards_list$boards
  marked &lt;-
    boards %&gt;% 
    mutate(across(.cols = 1:5, .fns = ~str_replace_all(string = ., pattern = selection, replacement = &quot;X&quot;)))
  row_win_card &lt;-
    marked %&gt;%
    mutate(row_bingo = str_count(str_c(V1,V2,V3,V4,V5),&quot;X&quot;)) %&gt;% 
    filter(row_bingo==5)  %&gt;% 
    pull(card_number)
  col_win_card &lt;-
    marked %&gt;% 
    mutate(across(.cols = V1:V5, .fns = ~ifelse(.==&quot;X&quot;,1,0))) %&gt;% 
    group_by(card_number) %&gt;% 
    summarise(across(everything(), ~sum(.))) %&gt;% 
    filter(V1 ==5|V2 ==5|V3 ==5|V4 ==5|V5 ==5) %&gt;% 
    pull(card_number)
  card_number &lt;- ifelse(length(row_win_card) &gt; 0, row_win_card, ifelse(length(col_win_card) &gt; 0, col_win_card, integer(0)))
  if(is.na(card_number)){card_number &lt;- integer(0)}
  out &lt;- list(boards = marked, win_card = card_number, selection = selection)
  return(out)
}

mark_board_poss &lt;- possibly(mark_board, otherwise = NULL)

winning_card &lt;- 
selections %&gt;% 
  accumulate(.f = mark_board_poss, .init = boards_list) %&gt;% 
  discard(is.null) %&gt;% 
  pluck(length(.)) 

winning_card$boards %&gt;% 
  filter(card_number == winning_card$win_card) %&gt;% 
  select(-card_number) %&gt;% 
  mutate(across(everything(), ~as.numeric(.))) %&gt;% 
  as.matrix() %&gt;% sum(na.rm = T) %&gt;% prod(as.numeric(winning_card$selection))</code></pre>
</div>
<div id="part-2-2" class="section level4">
<h4>Part 2</h4>
<pre class="r"><code>boards_list &lt;- list(boards = boards)

mark_board_2 &lt;- function(boards_list = boards_list, selection = selections[41]){

  if(max(boards_list$boards$winner)==100){stop(boards_list)}
  
  boards &lt;- boards_list$boards
  
  marked &lt;-
    boards %&gt;% 
    mutate(across(.cols = 1:5, .fns = ~str_replace_all(string = ., pattern = selection, replacement = &quot;X&quot;)))
  
  row_win_card &lt;-
    marked %&gt;%
    mutate(row_bingo = str_count(str_c(V1,V2,V3,V4,V5),&quot;X&quot;)) %&gt;% 
    filter(row_bingo==5)  %&gt;% 
    pull(card_number)
  
  col_win_card &lt;-
    marked %&gt;% 
    mutate(across(.cols = V1:V5, .fns = ~ifelse(.==&quot;X&quot;,1,0))) %&gt;% 
    group_by(card_number) %&gt;% 
    summarise(across(everything(), ~sum(.))) %&gt;% 
    filter(V1 ==5|V2 ==5|V3 ==5|V4 ==5|V5 ==5) %&gt;% 
    pull(card_number)
  
  if(length(row_win_card)&gt;0 &amp; nrow(marked) == 5){
    marked &lt;- 
      marked %&gt;% 
      mutate(winner = 100)
    return(out &lt;- list(boards = marked, selection = selection))
    } else if(length(row_win_card)&gt;0){
    marked &lt;- 
    marked %&gt;% 
      filter(!card_number %in% row_win_card)
  }
  if(length(col_win_card)&gt;0 &amp; nrow(marked) == 5){
    marked &lt;- 
    marked %&gt;% 
      mutate(winner = 100)
    return(out &lt;- list(boards = marked, selection = selection))
  } else if(length(col_win_card)&gt;0){
    marked &lt;- 
    marked %&gt;% 
      filter(!card_number %in% col_win_card)
  }
  
  out &lt;- list(boards = marked, selection = selection)
  
  return(out)
  
}

mark_board_2_poss &lt;- possibly(mark_board_2, otherwise = NULL)

winning_card &lt;-
selections %&gt;% 
  accumulate(mark_board_2_poss, .init = boards_list) %&gt;% 
  discard(is.null) %&gt;% 
  pluck(length(.))

winning_card$boards %&gt;% 
  select(V1:V5) %&gt;% 
  mutate(across(everything(), ~as.numeric(.))) %&gt;% 
  as.matrix() %&gt;% sum(na.rm = T) %&gt;% prod(as.numeric(winning_card$selection))</code></pre>
</div>
</div>
<div id="day-3" class="section level2">
<h2><a href="https://adventofcode.com/2021/day/3">Day 3</a></h2>
<p>I rely on several pivots, <code>unite()</code>, and the iterative function <code>purrr::reduce()</code> for this problem.</p>
<div id="part-1-3" class="section level4">
<h4>Part 1</h4>
<pre class="r"><code>tibble(binary = read_lines(&quot;day_3.txt&quot;)) %&gt;% 
  transmute(col = str_split_fixed(binary, pattern = &quot;&quot;, n = nchar(binary))) %&gt;% 
  pull(col) %&gt;% as_tibble() %&gt;% 
  summarise(across(.cols = everything(), .fns = ~if_else(mean(as.numeric(.))&gt;.5,1,0))) %&gt;% 
  pivot_longer(cols = everything(), values_to = &quot;gamma&quot;, names_to = &quot;slot&quot;)  %&gt;% 
  mutate(epsilon = if_else(gamma == 1, 0, 1)) %&gt;% 
  pivot_longer(cols = -slot) %&gt;% 
  pivot_wider(names_from = slot, values_from = value) %&gt;% 
  unite(col = &quot;binary&quot;,  where(is.double), sep = &quot;&quot;)  %&gt;% 
  mutate(decimal = strtoi(as.double(binary), base = 2)) %&gt;% 
  pull(decimal) %&gt;% prod()</code></pre>
</div>
<div id="part-2-3" class="section level4">
<h4>Part 2</h4>
<pre class="r"><code>data &lt;-
tibble(binary = read_lines(&quot;day_3.txt&quot;)) %&gt;% 
  transmute(col = str_split_fixed(binary, pattern = &quot;&quot;, n = nchar(binary))) %&gt;% 
  pull(col) %&gt;% as_tibble() %&gt;% 
  summarise(across(.cols = everything(), .fns = ~as.numeric(.))) 

filter_rating &lt;- function(data, col = &quot;V1&quot;, type = &quot;oxygen&quot;){
  if(nrow(data)==1){out &lt;- data} 
  else if(type == &quot;oxygen&quot;){out &lt;- data[data[,col]==if_else(mean(data[,col][[1]])&gt;=.5,1,0),]}
  else if(type == &quot;co2&quot;){out &lt;- data[data[,col]==if_else(mean(data[,col][[1]])&lt;.5,1,0),]}
}
  
reduce(.x = names(data), .f = filter_rating, .init = data, &quot;oxygen&quot;) %&gt;%
  unite(col = &quot;binary&quot;,everything(), sep = &quot;&quot;) %&gt;% 
  pull() %&gt;% strtoi(base = 2) *

reduce(.x = names(data), .f = filter_rating, .init = data, &quot;co2&quot;) %&gt;%
  unite(col = &quot;binary&quot;,everything(), sep = &quot;&quot;) %&gt;% 
  pull() %&gt;% strtoi(base = 2)</code></pre>
</div>
</div>
<div id="day-2" class="section level2">
<h2><a href="https://adventofcode.com/2021/day/2">Day 2</a></h2>
<p>Today I used <code>seperate()</code> and <code>cumsum()</code> to work this problem.</p>
<div id="part-1-4" class="section level4">
<h4>Part 1</h4>
<pre class="r"><code>tibble(x = read_lines(&quot;day_2.txt&quot;)) %&gt;% 
  separate(col = x, into = c(&quot;direction&quot;,&quot;distance&quot;), convert = TRUE) %&gt;% 
  group_by(real_direction = direction == &quot;forward&quot;) %&gt;% 
  mutate(distance = ifelse(direction == &quot;up&quot;, distance * -1, distance)) %&gt;% 
  summarise(movement = sum(distance)) %&gt;% 
  pull(movement) %&gt;% prod()</code></pre>
</div>
<div id="part-2-4" class="section level4">
<h4>Part 2</h4>
<pre class="r"><code>tibble(x = read_lines(&quot;day_2.txt&quot;)) %&gt;% 
  separate(col = x, into = c(&quot;direction&quot;,&quot;distance&quot;), convert = TRUE) %&gt;%
  mutate(distance = as.double(distance)) %&gt;% 
  mutate(aim_change = case_when(direction == &quot;forward&quot; ~ 0,
                                direction == &quot;down&quot; ~ distance,
                                direction == &quot;up&quot; ~ -1 * distance)) %&gt;% 
  mutate(aim = cumsum(aim_change)) %&gt;% 
  mutate(horizontal_position_increase = ifelse(direction == &quot;forward&quot;, distance, 0)) %&gt;% 
  mutate(depth_position_increase = ifelse(direction == &quot;forward&quot;, aim * distance,0)) %&gt;% 
  mutate(horizontal_position = cumsum(horizontal_position_increase)) %&gt;% 
  mutate(depth_position = cumsum(depth_position_increase)) %&gt;% 
  slice_tail(n = 1) %&gt;% 
  summarise(answer = horizontal_position * depth_position) </code></pre>
</div>
<div id="day-1" class="section level3">
<h3><a href="https://adventofcode.com/2021/day/1">Day 1</a></h3>
<p>Using <code>lag()</code> and <code>zoo::rollsum()</code> we are able to accomplish day one pretty easily.</p>
<div id="part-1-5" class="section level4">
<h4>Part 1</h4>
<pre class="r"><code>tibble(measurements = as.numeric(read_lines(&quot;day1.txt&quot;))) %&gt;%  
  filter(measurements &gt; lag(measurements,1)) %&gt;% 
  nrow()</code></pre>
</div>
<div id="part-2-5" class="section level4">
<h4>Part 2</h4>
<pre class="r"><code>tibble(measurements = as.numeric(read_lines(&quot;day1.txt&quot;))) %&gt;%
  mutate(roll_sum = zoo::rollsum(measurements,3, fill = NA, align = &quot;right&quot;)) %&gt;%
  filter(roll_sum &gt; lag(roll_sum,1)) %&gt;%
  nrow()</code></pre>
</div>
</div>
</div>
