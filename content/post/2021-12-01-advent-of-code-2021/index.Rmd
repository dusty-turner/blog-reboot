---
title: Advent of Code 2021
author: Dusty Turner
date: '2021-12-01'
slug: []
categories:
  - R
  - datascience
  - learning
  - teaching
tags:
  - R
  - Data Science
  - learning
  - teaching
cover: /media/advent2.JPG
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(message=FALSE, warning=FALSE, paged.print=FALSE, eval=F)
```

Every year, the great team at [Advent of Code](adventofcode.com) lead by [ericwastl](https://twitter.com/ericwastl) develops an "Advent calendar of small programming puzzles for a variety of skill sets and skill levels that can be solved in any programming language you like."  

Well, I like R, so in this post I will provide my solutions to the puzzles each day.  I plan on using this post to learn and teach and hopefully I am able to stay up-to-date!  

A few notes as we get started:

- Unless otherwise specified, all solutions rely on `library(tidyverse)`.
- All data is saved in the working directory as a `.txt` file.
- I can't promise my solutions will be the most elegant, but I will only post if they are correct!

On to the solutions...

#### Code supporting all solutions

```{r echo=TRUE, message=FALSE, warning=FALSE, paged.print=FALSE}
library(tidyverse)
```
 
 
 
## [Day 5](https://adventofcode.com/2021/day/5) 

#### Part 1

<!-- For this problem, I created a matrix to track the lines of the hydrothermic vents. In part one, each line was straight so I was able to build this matrix fairly simply.  I had to create a toggle for vents that were horizontal vs vertical. -->

```{r}
movements <-
  tibble(directions = read_lines("02_data/day_5.txt")) %>%
  mutate(directions = str_replace_all(string = directions, pattern = " -> ", ",")) %>% 
  separate(col = directions, into = c("x1", "y1", "x2", "y2"), sep = ",", convert = T) %>% 
  select(x1,x2,y1,y2) 

create_lines <- function(move){

if(move$y1==move$y2) {
  xlow  <- min(move$x1, min(move$x2))
  xhigh <- max(move$x1, min(move$x2))
  ylow  <- min(move$y1, min(move$y2))
  yhigh <- max(move$y1, min(move$y2))
  byrow <- T # for horizontal vents
} else if (move$x1 == move$x2) {
  ylow  <- min(move$x1, min(move$x2))
  yhigh <- max(move$x1, min(move$x2))
  xlow  <- min(move$y1, min(move$y2))
  xhigh <- max(move$y1, min(move$y2))
  byrow <- F # for vertical vents
}
out <- matrix(c(
  rep(rep(0,1000),ylow), ## zeroes before row/col
  c(rep(0,xlow),rep(1,xhigh-xlow+1), rep(0,999-xhigh)), ## row/col of 1s
  rep(rep(0,1000),999-ylow) ## zeroes after row/col
  ), byrow = byrow, nrow = 1000, ncol = 1000)
return(out)
}

movements %>% 
  filter(x1==x2 | y1==y2) %>% 
  group_split(row_number(), .keep = F) %>% 
  purrr::map(~create_lines(lines = .x)) %>% 
  reduce(`+`) %>% as_tibble() %>% 
  pivot_longer(cols = everything()) %>% 
  filter(value >=2) %>% 
  count()
```

#### Part 2

<!-- In this part some of the vents were diagonal.  I used the first function to mark the straight vents and created a second function to trace the ones at an angle.  I had to condition this off the top right to bottom left lines verses the top left to bottom right lines.  -->

```{r}
cross_routes <- function(move){

  xlow  <- min(move$x1, min(move$x2))
  xhigh <- max(move$x1, min(move$x2))
  ylow  <- min(move$y1, min(move$y2))
  yhigh <- max(move$y1, min(move$y2))

mat <- matrix(rep(0,1000000), ncol = 1000) # create a 1000 x 1000 matrix
if((move$x2>move$x1 & move$y2>move$y1) | (move$x2<move$x1 & move$y2<move$y1)){
  for (i in 1:length(xlow:xhigh)) {
    mat[ylow+i,xlow+i] <- 1
  }
} else{ ## vent is top left to bottom right
  for (i in 1:length(xlow:xhigh)) {
    mat[ylow+i,xhigh+2-i] <- 1
  }
}## determine if vent is top right to bottom left
return(mat)
}

striaght_lines <- # from part 1
  movements %>% 
  filter(x1==x2 | y1==y2) %>% # straight lines
  group_split(row_number(), .keep = F) %>% 
  purrr::map(~create_lines(lines = .x)) %>% 
  reduce(`+`) 

diagonal_lines <-
  movements %>%
  filter(x1!=x2 & y1!=y2) %>% # diagonal lines
  group_split(row_number(), .keep = F) %>% 
  purrr::map(~cross_routes(move = .x)) %>% 
  reduce(`+`) 
 
as_tibble(striaght_lines + diagonal_lines) %>% 
  pivot_longer(cols = everything()) %>%
  filter(value >=2) %>%
  count()

```


## [Day 4](https://adventofcode.com/2021/day/4)

I feel like this could be done more simply, but today I create a function that take the bingo number, adjudicates each board, determines if there is a winner, then outputs the next board.  Then we use `purrr::accumulate()` and `purrr::possibly()` to handle errors that I intentionally create.

#### Part 1

```{r}
data <- read_lines("day_4.txt")

selections <-
  data[1] %>% str_split(",") %>% unlist() %>% str_pad(2,"left") %>% str_pad(3,"right")

boards <-
  tibble(cards = data[-1]) %>% 
  filter(cards != "") %>%
  mutate(cards = str_squish(cards)) %>% 
  transmute(col = str_split_fixed(cards, pattern = " ", n = 5)) %>% 
  pull(col) %>% as_tibble() %>% 
  mutate(across(.cols = everything(),.fns = ~str_pad(str_pad(.,2,"left"),3,"right"))) %>% 
  mutate(card_number = sort(rep(1:(n()/5),5))) %>% 
  mutate(winner = 0)

boards_list <- list(boards = boards, win_card = integer(0))

mark_board <- function(boards_list = boards_list, selection = selections[1]){
  if(length(boards_list$win_card) > 0){stop(boards_list)}
  boards <- boards_list$boards
  marked <-
    boards %>% 
    mutate(across(.cols = 1:5, .fns = ~str_replace_all(string = ., pattern = selection, replacement = "X")))
  row_win_card <-
    marked %>%
    mutate(row_bingo = str_count(str_c(V1,V2,V3,V4,V5),"X")) %>% 
    filter(row_bingo==5)  %>% 
    pull(card_number)
  col_win_card <-
    marked %>% 
    mutate(across(.cols = V1:V5, .fns = ~ifelse(.=="X",1,0))) %>% 
    group_by(card_number) %>% 
    summarise(across(everything(), ~sum(.))) %>% 
    filter(V1 ==5|V2 ==5|V3 ==5|V4 ==5|V5 ==5) %>% 
    pull(card_number)
  card_number <- ifelse(length(row_win_card) > 0, row_win_card, ifelse(length(col_win_card) > 0, col_win_card, integer(0)))
  if(is.na(card_number)){card_number <- integer(0)}
  out <- list(boards = marked, win_card = card_number, selection = selection)
  return(out)
}

mark_board_poss <- possibly(mark_board, otherwise = NULL)

winning_card <- 
selections %>% 
  accumulate(.f = mark_board_poss, .init = boards_list) %>% 
  discard(is.null) %>% 
  pluck(length(.)) 

winning_card$boards %>% 
  filter(card_number == winning_card$win_card) %>% 
  select(-card_number) %>% 
  mutate(across(everything(), ~as.numeric(.))) %>% 
  as.matrix() %>% sum(na.rm = T) %>% prod(as.numeric(winning_card$selection))
```

#### Part 2

```{r}
boards_list <- list(boards = boards)

mark_board_2 <- function(boards_list = boards_list, selection = selections[41]){

  if(max(boards_list$boards$winner)==100){stop(boards_list)}
  
  boards <- boards_list$boards
  
  marked <-
    boards %>% 
    mutate(across(.cols = 1:5, .fns = ~str_replace_all(string = ., pattern = selection, replacement = "X")))
  
  row_win_card <-
    marked %>%
    mutate(row_bingo = str_count(str_c(V1,V2,V3,V4,V5),"X")) %>% 
    filter(row_bingo==5)  %>% 
    pull(card_number)
  
  col_win_card <-
    marked %>% 
    mutate(across(.cols = V1:V5, .fns = ~ifelse(.=="X",1,0))) %>% 
    group_by(card_number) %>% 
    summarise(across(everything(), ~sum(.))) %>% 
    filter(V1 ==5|V2 ==5|V3 ==5|V4 ==5|V5 ==5) %>% 
    pull(card_number)
  
  if(length(row_win_card)>0 & nrow(marked) == 5){
    marked <- 
      marked %>% 
      mutate(winner = 100)
    return(out <- list(boards = marked, selection = selection))
    } else if(length(row_win_card)>0){
    marked <- 
    marked %>% 
      filter(!card_number %in% row_win_card)
  }
  if(length(col_win_card)>0 & nrow(marked) == 5){
    marked <- 
    marked %>% 
      mutate(winner = 100)
    return(out <- list(boards = marked, selection = selection))
  } else if(length(col_win_card)>0){
    marked <- 
    marked %>% 
      filter(!card_number %in% col_win_card)
  }
  
  out <- list(boards = marked, selection = selection)
  
  return(out)
  
}

mark_board_2_poss <- possibly(mark_board_2, otherwise = NULL)

winning_card <-
selections %>% 
  accumulate(mark_board_2_poss, .init = boards_list) %>% 
  discard(is.null) %>% 
  pluck(length(.))

winning_card$boards %>% 
  select(V1:V5) %>% 
  mutate(across(everything(), ~as.numeric(.))) %>% 
  as.matrix() %>% sum(na.rm = T) %>% prod(as.numeric(winning_card$selection))
```


## [Day 3](https://adventofcode.com/2021/day/3)

I rely on several pivots, `unite()`, and the iterative function `purrr::reduce()` for this problem. 

#### Part 1

```{r}
tibble(binary = read_lines("day_3.txt")) %>% 
  transmute(col = str_split_fixed(binary, pattern = "", n = nchar(binary))) %>% 
  pull(col) %>% as_tibble() %>% 
  summarise(across(.cols = everything(), .fns = ~if_else(mean(as.numeric(.))>.5,1,0))) %>% 
  pivot_longer(cols = everything(), values_to = "gamma", names_to = "slot")  %>% 
  mutate(epsilon = if_else(gamma == 1, 0, 1)) %>% 
  pivot_longer(cols = -slot) %>% 
  pivot_wider(names_from = slot, values_from = value) %>% 
  unite(col = "binary",  where(is.double), sep = "")  %>% 
  mutate(decimal = strtoi(as.double(binary), base = 2)) %>% 
  pull(decimal) %>% prod()
```

#### Part 2

```{r}
data <-
tibble(binary = read_lines("day_3.txt")) %>% 
  transmute(col = str_split_fixed(binary, pattern = "", n = nchar(binary))) %>% 
  pull(col) %>% as_tibble() %>% 
  summarise(across(.cols = everything(), .fns = ~as.numeric(.))) 

filter_rating <- function(data, col = "V1", type = "oxygen"){
  if(nrow(data)==1){out <- data} 
  else if(type == "oxygen"){out <- data[data[,col]==if_else(mean(data[,col][[1]])>=.5,1,0),]}
  else if(type == "co2"){out <- data[data[,col]==if_else(mean(data[,col][[1]])<.5,1,0),]}
}
  
reduce(.x = names(data), .f = filter_rating, .init = data, "oxygen") %>%
  unite(col = "binary",everything(), sep = "") %>% 
  pull() %>% strtoi(base = 2) *

reduce(.x = names(data), .f = filter_rating, .init = data, "co2") %>%
  unite(col = "binary",everything(), sep = "") %>% 
  pull() %>% strtoi(base = 2)

```


## [Day 2](https://adventofcode.com/2021/day/2)

Today I used `seperate()` and `cumsum()` to work this problem.

#### Part 1

```{r}
tibble(x = read_lines("day_2.txt")) %>% 
  separate(col = x, into = c("direction","distance"), convert = TRUE) %>% 
  group_by(real_direction = direction == "forward") %>% 
  mutate(distance = ifelse(direction == "up", distance * -1, distance)) %>% 
  summarise(movement = sum(distance)) %>% 
  pull(movement) %>% prod()
```

#### Part 2

```{r}
tibble(x = read_lines("day_2.txt")) %>% 
  separate(col = x, into = c("direction","distance"), convert = TRUE) %>%
  mutate(distance = as.double(distance)) %>% 
  mutate(aim_change = case_when(direction == "forward" ~ 0,
                                direction == "down" ~ distance,
                                direction == "up" ~ -1 * distance)) %>% 
  mutate(aim = cumsum(aim_change)) %>% 
  mutate(horizontal_position_increase = ifelse(direction == "forward", distance, 0)) %>% 
  mutate(depth_position_increase = ifelse(direction == "forward", aim * distance,0)) %>% 
  mutate(horizontal_position = cumsum(horizontal_position_increase)) %>% 
  mutate(depth_position = cumsum(depth_position_increase)) %>% 
  slice_tail(n = 1) %>% 
  summarise(answer = horizontal_position * depth_position) 

```


### [Day 1](https://adventofcode.com/2021/day/1)

Using `lag()` and `zoo::rollsum()` we are able to accomplish day one pretty easily.

#### Part 1

```{r}
tibble(measurements = as.numeric(read_lines("day1.txt"))) %>%  
  filter(measurements > lag(measurements,1)) %>% 
  nrow()
```

#### Part 2

```{r}
tibble(measurements = as.numeric(read_lines("day1.txt"))) %>%
  mutate(roll_sum = zoo::rollsum(measurements,3, fill = NA, align = "right")) %>%
  filter(roll_sum > lag(roll_sum,1)) %>%
  nrow()
```

