---
title: Advent of Code 2021
author: Dusty Turner
date: '2021-12-01'
slug: []
categories:
  - R
  - datascience
  - learning
  - teaching
tags:
  - R
  - Data Science
  - learning
  - teaching
cover: /media/advent2.JPG
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(message=FALSE, warning=FALSE, paged.print=FALSE, eval=F, cache = F)
```

Every year, the great team at [Advent of Code](adventofcode.com) lead by [ericwastl](https://twitter.com/ericwastl) develops an "Advent calendar of small programming puzzles for a variety of skill sets and skill levels that can be solved in any programming language you like."  

Well, I like R, so in this post I will provide my solutions to the puzzles each day.  I plan on using this post to learn and teach and hopefully I am able to stay up-to-date!  

A few notes as we get started:

- Unless otherwise specified, all solutions rely on `library(tidyverse)`.
- All data is saved in the working directory as a `.txt` file.
- I can't promise my solutions will be the most elegant, but I will only post if they are correct!

On to the solutions...

#### Code supporting all solutions 

```{r echo=TRUE, message=FALSE, warning=FALSE, paged.print=FALSE, eval = T, cashe = T}
library(tidyverse)
library(furrr)
plan(multicore)
```
 

## [Day 11](https://adventofcode.com/2021/day/11)  

#### Part 1

In previous attempts, I've moved through the entire plane making changes as I get to them.  This time, I took a page from [David Robinsion's](https://twitter.com/drob) playbook and used `crossing()`.  I then used a while loop to progress through the octopus stages

```{r}
x <-
  tibble(x = (read_lines("day_11.txt"))) %>% 
  mutate(row = row_number()) %>% 
  mutate(value = str_split(x,"")) %>% 
  unnest(value) %>% 
  mutate(value = as.numeric(value)) %>% 
  group_by(row) %>% 
  mutate(col = row_number()) %>% 
  ungroup() %>% 
  relocate(value, .after = col) %>% 
  select(-x)

adj <- expand.grid(xd = c(-1,0,1), yd = c(-1,0,1))

adjacent <- function(x){
  d <- x %>% distinct(row,col,value)
  d2 <- x %>% distinct(row,col,value)
  d %>% 
    crossing(adj) %>% 
    mutate(row2 = row +xd,
           col2 = col + yd) %>%
    arrange(row,col) %>% 
    inner_join(d2, by = c(row2 = "row", col2 = "col"), suffix = c("", "2")) %>% 
    filter(row != row2 | col != col2)  
}

flash_octopus <- function(x = x, iteration = 1) {
  x <- x$x %>%
    adjacent() %>%
    mutate(across(.cols = c("value", "value2"), .fns = ~ . + 1))
  tens <- 1
  while (tens != 0) {
    x <- x %>%
      group_by(row, col) %>%  mutate(add_this_many = sum(value2 >= 10)) %>% ungroup() %>%
      mutate(value = ifelse(value >= 10,-100, value)) %>%
      mutate(value = value + add_this_many) %>%
      adjacent()
    tens <- x %>% distinct(row, col, value) %>% filter(value >= 10) %>% nrow()
  }
  flashes <- x %>% distinct(row, col, value) %>% count(did_flash = value < 0) %>% filter(did_flash) %>% pull(n)
  if (length(flashes) == 0) {flashes <- 0}
  x <- x %>% mutate(value = ifelse(value < 0, 0, value))
  x <- list(x = x, flashes = flashes)
  return(x)
}

x <- list(x = x, flashes = 0)

## Answer 1
accumulate(1:100, .f = flash_octopus, .init = x) %>% one_hundred %>% map(2) %>% unlist() %>% sum()
```

#### Part 2

For part 2, let it run longer and find the first element that has 100 flashes.

```{r}
three_hundred <- accumulate(1:300, .f = flash_octopus, .init = x)

which(unlist(map(three_hundred, 2)) == 100)[1] - 1
```

I also want to provide this function that proved helpful in viewing the matrix throughout. 

```{r}
see_matrix <- function(data = x){
  data %>% 
    distinct(row, col, value) %>% 
    select(row,col,value) %>% 
    pull(value) %>% 
    matrix(nrow = 10, byrow = T)
}
```


## [Day 10](https://adventofcode.com/2021/day/10) 

#### Part 1

I use a while loop to remove all 'open' 'close' pairings.  This helps find both corrupted and broken chunks.  I find the corrupted chunks and apply the scoring mechanism.

```{r}
input <-
  tibble(chunks = read_lines("day_10.txt"))

syntax_error_points <- ## points for each bracket type
  tibble(chunks = c(")", "]", "}", ">"),
         points = c(3, 57, 1197, 25137)
         )

input_list <- list(NULL, input) ## prepare list for iteration

i <- 2 ## initialize iterator 
while (!isTRUE(all.equal(input_list[i], input_list[i - 1]))) {
  input <-  input %>%
    mutate(chunks = str_remove_all(string = chunks, pattern = "<>|\\[\\]|\\(\\)|\\{\\}"))
  i = i + 1
  input_list[[i]] <- input
} ## this iteratively removes all open/closed pairings until the df does not change between iterations

input_list %>% tail(1) %>% pluck(1) %>% ## select the last list
  mutate(chunks = str_remove_all(string = chunks, pattern = "<|\\[|\\(|\\{")) %>% ## remove openings
  filter(chunks != "") %>% ## remove extraneous lines
  mutate(chunks = str_sub(chunks, 1, 1)) %>% ## select the first opening
  count(chunks) %>% ## count them up!
  left_join(syntax_error_points, by = "chunks") %>%  ## join in points
  summarise(score = sum(n * points)) ## score the process
```

## Part 2

I take the incomplete chunks from the previous part and map over the score_points function for the final answer.

```{r}
incomplete_df <- ## identify chunks with incomplete strings
  input_list %>% tail(1) %>% pluck(1) %>% ## selects list element with all open/closed pairs removed
  mutate(chunks = str_remove_all(string = chunks, pattern = "<|\\[|\\(|\\{")) %>% ## removes opens
  mutate(incomplete_strings = row_number()) %>% ## ids each pattern
  filter(chunks == "") %>% ## removes extraneous lines
  select(id = chunks, incomplete_strings) ## now have df with incomplete strings identified

matching_df <- ## create scoring df for joining later
  tibble(
    chunks = c("(", "[", "{", "<"),
    right = c(")", "]", "}", ">"),
    points = c(1, 2, 3, 4))

incomplete_list <-  ## creates list of points
  input %>%  mutate(incomplete_strings = row_number()) %>%
  semi_join(incomplete_df, by = "incomplete_strings") %>% ## only keep the chunks that are incomplete
  separate_rows(chunks, sep = "") %>% 
  left_join(matching_df, by = "chunks") %>% ## add in points
  filter(!is.na(right)) %>%
  group_by(incomplete_strings) %>% mutate(row_num = row_number()) %>% arrange(desc(row_num)) %>%
  select(-row_num) %>% ## puts the chunks in the right order
  group_split() %>% ## splits them for future map function
  map(.f = ~ pull(.data = .x, points)) ## only keeps the column we want

score_points <- function(current_vector = points, index) {
    current_vector[index] <- current_vector[index - 1] * 5 + current_vector[index]
    return(current_vector)} ## function to execute partial scoring function

score_everything <- function(data) {
  2:length(data) %>%
    reduce(.f = score_points, .init = data) %>%
    tail(1)} ## function which scores entire vector

incomplete_list %>%
  map_dbl(.f = ~ score_everything(data = .x)) %>%
  sort() %>% median() ## maps all lists over scoring function

```


## [Day 9](https://adventofcode.com/2021/day/9) 

#### Part 1

To find the number of low points I map across a function that determines if each place is a depression. After the identification, I use the problems formula to sum up the risk levels.

```{r}
input <-
  matrix(read_lines("02_data/day_9.txt")) %>% 
  strsplit("") %>% unlist() %>% as.numeric() %>% matrix(byrow = T, nrow = 100) 

checker <- function(row, col){
  if(col < ncol(input)){right <- input[row,col]-input[row,col+1] < 0}else{right<-1} # check right
  if(col != 1)         {left  <- input[row,col]-input[row,col-1] < 0}else{left<-1}  # check left
  if(row != 1)         {upper <- input[row,col]-input[row-1,col] < 0}else{upper<-1} # check up
  if(row < nrow(input)){lower <- input[row,col]-input[row+1,col] < 0}else{lower<-1} # check down
  
  out <- tibble(number = input[row,col], row = row, col = col, 
                num_increase = sum(right,left,upper,lower)) # this sums every direction that has an increase
  return(out)
}

future_map2_dfr(.x = sort(rep(1:nrow(input),ncol(input))),
                .y = rep(1:ncol(input),nrow(input)),
                .f = ~checker(row = .x,col = .y), .progress = T) %>% 
  filter(num_increase == 4) %>% 
  mutate(number = number + 1) %>% 
  summarise(answer = sum(number))
```

#### Part 2

I again map over a function that looks in all directions and determines if it is touching a place that is not a 9. I count the basins one at a time and add up the size of the basins.

```{r}
id_reduce_count_replace <- function(input){
  input <- unique.matrix(input$input, MARGIN = 1) ## gets rid of rows already searched to speed up code
  input <- t(input) %>% str_c(collapse = "") %>% str_replace(pattern = "[^X]", replacement = "B") %>% 
    str_split(pattern = "") %>% unlist() %>% matrix(byrow = T, nrow = nrow(input))
    ## above determines first spot of basin in top row
  identified_basin <- reduce2(.x = ## there is probably a better way to come up with these vectors to map over
                                c(sort(rep(1:nrow(input),ncol(input))),
                                  rev(sort(rep(1:nrow(input),ncol(input)))),
                                  sort(rep(1:nrow(input),ncol(input))),
                                  rev(sort(rep(1:nrow(input),ncol(input))))),
                              .y = 
                                c(rep(1:ncol(input),nrow(input)),
                                  rep(1:ncol(input),nrow(input)),
                                  rev(rep(1:ncol(input),nrow(input)),
                                  rep(1:ncol(input),nrow(input)))), 
                              .f = sweep, .init = input) ## iterates over all places on matrix to determine if basin
  
  basin_size <- identified_basin %>%  str_count("B") %>% sum() # identify to of new basin

  input <- str_replace_all(identified_basin,"B", "X") %>% matrix(byrow = F, nrow = nrow(input)) # delete basin tracking
  
  if(sum(str_count(input, pattern = "X"))==sum(nchar(input))){message("Finished")} # create an error if complete

  return(list(input = input, basin_size = basin_size))
}

initial <-
  matrix(read_lines("02_data/day_9.txt")) %>%
  strsplit("") %>% unlist() %>% str_replace_all(pattern = "9","X") %>% 
  matrix(byrow = T, nrow = 100) 

input <- list(input = initial, basin_size = NULL)

sweep <- function(input, row, col){
  if(col != ncol(input))  {input[row,col][input[row,col+1]=="B" && input[row,col] !="X"] <- "B"} # look right
  if(row != nrow(input))  {input[row,col][input[row+1,col]=="B" && input[row,col] !="X"] <- "B"} # look down
  if(col != 1)            {input[row,col][input[row,col-1]=="B" && input[row,col] !="X"] <- "B"} # look left
  if(row != 1)            {input[row,col][input[row-1,col]=="B" && input[row,col] !="X"] <- "B"} # look up
  return(input)
}

tictoc::tic()
accumulate(.x = 1:225, .f = id_reduce_count_replace, .init = input) %>% map(2) %>% unlist() %>% sort() %>% tail(3) %>% prod()
tictoc::toc()
## took just under 300 seconds

```


## [Day 8](https://adventofcode.com/2021/day/8) 

#### Part 1

For part 1, I separate the string to grab the element of interest, I count the length of the unique output values, and count how many time this happens.

```{r}
tibble(entry = read_lines("day_8.txt")) %>%
  separate(col = entry, into = c("NA","output"),sep = " \\| ") %>% 
  mutate(id = row_number()) %>%
  separate_rows(output, sep = " ") %>% 
  mutate(length = nchar(output)) %>% 
  count(length) %>%
  filter(length %in% c(2,3,4,7)) %>%
  summarise(sum = sum(n))
```

#### Part 2

Part 2 is a little less elegant. I extract the signal patterns and use a set of functions to identify which strings become each number. I then map over all entrys to identify the letters.  Next I join in the output values to determine the numerical output values.

```{r}
initial <-
  tibble(entry = read_lines("day_8.txt")) %>%
  separate(col = entry, into = c("signal","output"),sep = " \\| ") %>% 
  mutate(id = row_number()) %>%
  separate_rows(signal, sep = " ") %>% 
  rowwise() %>% 
  mutate(signal = str_c(sort(unlist(str_split(signal,""))), collapse = "")) %>% ungroup() %>% 
  select(-output)

output_tbl <-
  tibble(entry = read_lines("day_8.txt")) %>%
  separate(col = entry, into = c("signal","output"),sep = " \\| ") %>% 
  mutate(id = row_number()) %>%
  separate_rows(output, sep = " ") %>% 
  rowwise() %>% 
  mutate(output = str_c(sort(unlist(str_split(output,""))), collapse = "")) %>% ungroup() %>% 
  select(-signal) %>% 
  group_by(id) %>% 
  summarise(output = str_c(output, collapse = " ")) %>% 
  ungroup() %>% 
  separate_rows(output, sep = " ") %>% 
  mutate(order = row_number())

identify_obvious <- function(initial){
  out <- initial %>% 
    mutate(number = case_when(nchar(signal) == 2 ~ 1,
                              nchar(signal) == 3 ~ 7,
                              nchar(signal) == 4 ~ 4,
                              nchar(signal) == 7 ~ 8,
                              TRUE ~ 0
                              )) %>% 
    filter(number !=0) %>% 
    arrange(number)
  return(out)
}
  
identify_3 <- function(known, initial){
  seven <-
    known  %>% filter(number %in% c(7)) %>% 
    pull(signal) %>% str_split("") %>% unlist()
  three <-  
    initial %>% 
    filter(nchar(signal) == 5) %>% 
    mutate(split = signal) %>% 
    separate_rows(split, sep = "") %>% 
    filter(split %in% seven) %>% 
    group_by(signal) %>% filter(n() == 3) %>% ungroup(signal) %>% 
    distinct(signal, .keep_all = T) %>% 
    select(-split) %>% 
    mutate(number = 3) %>% 
    bind_rows(known) %>% 
    arrange(number)
  return(three)
}

identify_9 <- function(known, initial){
  three <-
    known  %>% filter(number %in% c(3)) %>% 
    pull(signal) %>% str_split("") %>% unlist()
  nine <-
    initial %>% 
    filter(nchar(signal) == 6) %>% 
    mutate(split = signal) %>% 
    separate_rows(split, sep = "") %>% 
    filter(split %in% three) %>% 
    group_by(signal) %>% filter(n() == 5) %>% ungroup(signal) %>% 
    distinct(signal, .keep_all = T) %>% 
    select(-split) %>% 
    mutate(number = 9) %>% 
    bind_rows(known) %>% 
    arrange(number)
  return(nine)
}

identify_0 <- function(known, initial){
  one <-
    known  %>% 
    filter(number %in% c(1)) %>% 
    pull(signal) %>% 
    str_split("") %>% unlist()
  zero <-
    initial %>% 
    anti_join(known, by = c("signal", "id")) %>% 
    filter(nchar(signal) == 6) %>%   
    mutate(split = signal) %>% 
    separate_rows(split, sep = "") %>% 
    filter(split %in% one) %>% 
    group_by(signal) %>% filter(n() == 2) %>% ungroup(signal) %>% 
    distinct(signal, .keep_all = T) %>% 
    select(-split) %>% 
    mutate(number = 0) %>% 
    bind_rows(known) %>% 
    arrange(number)
  return(zero)
}

identify_6 <- function(known, initial){
  known <-
    initial %>% 
    anti_join(known, by = c("signal", "id")) %>% 
    filter(nchar(signal) == 6) %>%
    mutate(number = 6) %>% 
    bind_rows(known) %>% 
    arrange(number)
  return(known)
}

identify_5_2 <- function(known, initial){
  part <-
    known %>% 
    filter(number %in% c(1,4)) %>% 
    separate_rows(signal, sep = "") %>% 
    group_by(signal) %>% filter(n()==1) %>% 
    pull(signal) %>% str_split("") %>% unlist()
  last <- 
    initial %>% 
    anti_join(known, by = c("signal", "id")) %>% 
    mutate(side = signal) %>% 
    separate_rows(side, sep = "")  %>% 
    filter(side %in% part) %>% 
    group_by(signal) %>% 
    mutate(number = if_else(n()==2,5,2)) %>% 
    ungroup() %>% select(-side) %>% distinct() %>% 
    bind_rows(known) %>% 
    arrange(number)
return(last)
}

all_together <- function(initial) {
  all <-
    initial %>%
    identify_obvious() %>%
    identify_3(initial = initial) %>%
    identify_9(initial = initial) %>%
    identify_0(initial = initial) %>%
    identify_6(initial = initial) %>%
    identify_5_2(initial = initial)
  return(all)
}

initial %>% group_split(id) %>% 
  map_df(~all_together(initial = .x)) %>% 
  left_join(output_tbl, by = c("signal" = "output", "id" = "id")) %>% 
  filter(!is.na(order)) %>% arrange(order) %>% 
  group_by(id) %>% 
  summarise(signal = str_c(signal, collapse = " "), 
            number = as.numeric(str_c(number, collapse = ""))) %>% 
  summarise(solution = sum(number))
  
```


## [Day 7](https://adventofcode.com/2021/day/7) 

#### Part 1

To solve part 1, I create a function that finds the distance between all points to a specific point, map across all specific points, and then find the minimum distance.

<!-- dat <- read_lines("content/post/2021-12-01-advent-of-code-2021/day_7.txt") %>% str_split(",") %>% unlist() %>% as.numeric() -->

```{r}
dat <- as.numeric(unlist(str_split(read_lines("02_data/day_7.txt"),","))) 

distance <- function(data = dat, position) {
  out <- sum(abs(data - position))
  return(out)
}

min(dat):max(dat) %>% 
  map_dbl(.f = ~distance(data = dat, position = .x)) %>% min()

```

#### Part 2

I alter the distance formula to find the triangular number between two numbers. This can also be factored into the binomial coefficient with the upper index being the distance between the numbers and 2 as the lower index.


```{r}
distance_plus <- function(data = dat, position) {
  n <-abs(data-position)+1
  out <- sum(choose(n,2))
  return(out)
}

min(dat):max(dat) %>% 
  map_dbl(.f = ~distance_plus(data = dat, position = .x)) %>% min()
```

#### Code Golfing

This last code chunk is my attempt at 'code golfing' - aka - how succinct can I make my code.  I can answer both parts with fairly brief code, but I think its less understandable.

```{r}
fuel_calculation <- function(data = dat, position, type) {
  if(type == "distance"){out <- tibble(fuel = sum(abs(data - position)), position = position, type)}
  if(type == "triangular"){out <- tibble(fuel = sum(choose(abs(data-position)+1,2)), position = position, type)}
  return(out)
}

rep(min(dat):max(dat), 2) %>%
  map2_dfr(.y = c(rep("distance", length(min(dat):max(dat))), rep("triangular", length(min(dat):max(dat)))),
    .f = ~ fuel_calculation(data = dat,position = .x, type = .y)) %>%
  group_split(type) %>%
  map( ~ filter(.x, fuel == min(fuel)))
```




## [Day 6](https://adventofcode.com/2021/day/6) 

#### Part 1 and 2

My gut instinct is to always think in 'tidy' coding concepts. This will get the answer, but when moving from part 1 to part 2, the time it takes to run the code becomes computationally infeasible with my computer. I'll show my 3 attempts.

#### Strike 1

```{r echo=TRUE, cache=TRUE, eval = T} 
initial_fish <- tibble(fish = read_lines("day_6.txt")) %>%
  separate_rows(fish, sep = ",", convert = T) 

progress_day <- function(fish = initial_fish, after_day = 1){
fish <-
  fish %>% 
  mutate(fish = ifelse(fish <= 0 , "6,8", fish-1)) %>% 
  separate_rows(fish, sep = ",", convert = T) 
return(fish)
}

tictoc::tic()
ans <- 1:80 %>% 
# ans <- 1:256 %>% nope!
  reduce(.f = progress_day, .init = initial_fish) %>% nrow()
tictoc::toc()
```

My second attempt was a 'non-tidy' solution, but part 2 also took too long to run.

#### Strike 2

```{r echo=TRUE, cache=TRUE, eval = T} 
initial_fish <- as.numeric(unlist(strsplit(readr::read_lines("day_6.txt"),",")))

progress_day <- function(fish = initial_fish, after_day = 1) {
  
  add_fish <- sum(fish == 0)
  next_day <- fish - 1
  next_day[next_day < 0] <- 6

  out <- c(next_day, rep(8, add_fish))
return(out)  
}

tictoc::tic()
ans <- 1:150 %>% 
# ans <- 1:256 %>% faster, but nope! 
  reduce(.f = progress_day, .init = initial_fish) %>% length()
tictoc::toc() 
```

Lastly, instead of building out a vector for each fish, I decided to count the number of fish at each state of their birthing countdown.  This make things work nice and quick.

#### Success!

```{r echo=TRUE, cache=TRUE, eval = T} 
fish <- as.numeric(unlist(strsplit(read_lines("day_6.txt"),",")))
 
initial_fish <- c(
length(fish[fish==8]),
length(fish[fish==7]),
length(fish[fish==6]),
length(fish[fish==5]),
length(fish[fish==4]),
length(fish[fish==3]),
length(fish[fish==2]),
length(fish[fish==1]),
length(fish[fish==0]))

progress_day <- function(fish = initial_fish, after_day = 1){

births = fish[9]
get_older <- replace_na(lag(fish),0)
out <- c(births, get_older[2], get_older[3]+births, get_older[-c(1:3)])
return(out)
}

tictoc::tic()
ans <- 1:256 %>% 
  reduce(.f = progress_day, .init = initial_fish) %>% sum()
tictoc::toc()
```


## [Day 5](https://adventofcode.com/2021/day/5) 

#### Part 1

For this problem, I created a matrix to track the lines of the hydrothermic vents. In part one, each line was straight so I was able to build this matrix fairly simply.  I had to create a toggle for vents that were horizontal vs vertical.

```{r}
movements <-
  tibble(directions = read_lines("day_5.txt")) %>%
  mutate(directions = str_replace_all(string = directions, pattern = " -> ", ",")) %>% 
  separate(col = directions, into = c("x1", "y1", "x2", "y2"), sep = ",", convert = T) %>% 
  select(x1,x2,y1,y2) 

create_lines <- function(move){

if(move$y1==move$y2) {
  xlow  <- min(move$x1, min(move$x2))
  xhigh <- max(move$x1, min(move$x2))
  ylow  <- min(move$y1, min(move$y2))
  yhigh <- max(move$y1, min(move$y2))
  byrow <- T # for horizontal vents
} else if (move$x1 == move$x2) {
  ylow  <- min(move$x1, min(move$x2))
  yhigh <- max(move$x1, min(move$x2))
  xlow  <- min(move$y1, min(move$y2))
  xhigh <- max(move$y1, min(move$y2))
  byrow <- F # for vertical vents
}
out <- matrix(c(
  rep(rep(0,1000),ylow), ## zeroes before row/col
  c(rep(0,xlow),rep(1,xhigh-xlow+1), rep(0,999-xhigh)), ## row/col of 1s
  rep(rep(0,1000),999-ylow) ## zeroes after row/col
  ), byrow = byrow, nrow = 1000, ncol = 1000)
return(out)
}

movements %>% 
  filter(x1==x2 | y1==y2) %>% 
  group_split(row_number(), .keep = F) %>% 
  purrr::map(~create_lines(lines = .x)) %>% 
  reduce(`+`) %>% as_tibble() %>% 
  pivot_longer(cols = everything()) %>% 
  filter(value >=2) %>% 
  count()
```

#### Part 2

In this part some of the vents were diagonal.  I used the first function to mark the straight vents and created a second function to trace the ones at an angle.  I had to condition this off the top right to bottom left lines verses the top left to bottom right lines.

```{r}
cross_routes <- function(move){

  xlow  <- min(move$x1, min(move$x2))
  xhigh <- max(move$x1, min(move$x2))
  ylow  <- min(move$y1, min(move$y2))
  yhigh <- max(move$y1, min(move$y2))

mat <- matrix(rep(0,1000000), ncol = 1000) # create a 1000 x 1000 matrix
if((move$x2>move$x1 & move$y2>move$y1) | (move$x2<move$x1 & move$y2<move$y1)){
  for (i in 1:length(xlow:xhigh)) {
    mat[ylow+i,xlow+i] <- 1
  }
} else{ ## vent is top left to bottom right
  for (i in 1:length(xlow:xhigh)) {
    mat[ylow+i,xhigh+2-i] <- 1
  }
}## determine if vent is top right to bottom left
return(mat)
}

striaght_lines <- # from part 1
  movements %>% 
  filter(x1==x2 | y1==y2) %>% # straight lines
  group_split(row_number(), .keep = F) %>% 
  purrr::map(~create_lines(lines = .x)) %>% 
  reduce(`+`) 

diagonal_lines <-
  movements %>%
  filter(x1!=x2 & y1!=y2) %>% # diagonal lines
  group_split(row_number(), .keep = F) %>% 
  purrr::map(~cross_routes(move = .x)) %>% 
  reduce(`+`) 
 
as_tibble(striaght_lines + diagonal_lines) %>% 
  pivot_longer(cols = everything()) %>%
  filter(value >=2) %>%
  count()

```


## [Day 4](https://adventofcode.com/2021/day/4)

I feel like this could be done more simply, but today I create a function that take the bingo number, adjudicates each board, determines if there is a winner, then outputs the next board.  Then we use `purrr::accumulate()` and `purrr::possibly()` to handle errors that I intentionally create.

#### Part 1

```{r}
data <- read_lines("day_4.txt")

selections <-
  data[1] %>% str_split(",") %>% unlist() %>% str_pad(2,"left") %>% str_pad(3,"right")

boards <-
  tibble(cards = data[-1]) %>% 
  filter(cards != "") %>%
  mutate(cards = str_squish(cards)) %>% 
  transmute(col = str_split_fixed(cards, pattern = " ", n = 5)) %>% 
  pull(col) %>% as_tibble() %>% 
  mutate(across(.cols = everything(),.fns = ~str_pad(str_pad(.,2,"left"),3,"right"))) %>% 
  mutate(card_number = sort(rep(1:(n()/5),5))) %>% 
  mutate(winner = 0)

boards_list <- list(boards = boards, win_card = integer(0))

mark_board <- function(boards_list = boards_list, selection = selections[1]){
  if(length(boards_list$win_card) > 0){stop(boards_list)}
  boards <- boards_list$boards
  marked <-
    boards %>% 
    mutate(across(.cols = 1:5, .fns = ~str_replace_all(string = ., pattern = selection, replacement = "X")))
  row_win_card <-
    marked %>%
    mutate(row_bingo = str_count(str_c(V1,V2,V3,V4,V5),"X")) %>% 
    filter(row_bingo==5)  %>% 
    pull(card_number)
  col_win_card <-
    marked %>% 
    mutate(across(.cols = V1:V5, .fns = ~ifelse(.=="X",1,0))) %>% 
    group_by(card_number) %>% 
    summarise(across(everything(), ~sum(.))) %>% 
    filter(V1 ==5|V2 ==5|V3 ==5|V4 ==5|V5 ==5) %>% 
    pull(card_number)
  card_number <- ifelse(length(row_win_card) > 0, row_win_card, ifelse(length(col_win_card) > 0, col_win_card, integer(0)))
  if(is.na(card_number)){card_number <- integer(0)}
  out <- list(boards = marked, win_card = card_number, selection = selection)
  return(out)
}

mark_board_poss <- possibly(mark_board, otherwise = NULL)

winning_card <- 
selections %>% 
  accumulate(.f = mark_board_poss, .init = boards_list) %>% 
  discard(is.null) %>% 
  pluck(length(.)) 

winning_card$boards %>% 
  filter(card_number == winning_card$win_card) %>% 
  select(-card_number) %>% 
  mutate(across(everything(), ~as.numeric(.))) %>% 
  as.matrix() %>% sum(na.rm = T) %>% prod(as.numeric(winning_card$selection))
```

#### Part 2

```{r}
boards_list <- list(boards = boards)

mark_board_2 <- function(boards_list = boards_list, selection = selections[41]){

  if(max(boards_list$boards$winner)==100){stop(boards_list)}
  
  boards <- boards_list$boards
  
  marked <-
    boards %>% 
    mutate(across(.cols = 1:5, .fns = ~str_replace_all(string = ., pattern = selection, replacement = "X")))
  
  row_win_card <-
    marked %>%
    mutate(row_bingo = str_count(str_c(V1,V2,V3,V4,V5),"X")) %>% 
    filter(row_bingo==5)  %>% 
    pull(card_number)
  
  col_win_card <-
    marked %>% 
    mutate(across(.cols = V1:V5, .fns = ~ifelse(.=="X",1,0))) %>% 
    group_by(card_number) %>% 
    summarise(across(everything(), ~sum(.))) %>% 
    filter(V1 ==5|V2 ==5|V3 ==5|V4 ==5|V5 ==5) %>% 
    pull(card_number)
  
  if(length(row_win_card)>0 & nrow(marked) == 5){
    marked <- 
      marked %>% 
      mutate(winner = 100)
    return(out <- list(boards = marked, selection = selection))
    } else if(length(row_win_card)>0){
    marked <- 
    marked %>% 
      filter(!card_number %in% row_win_card)
  }
  if(length(col_win_card)>0 & nrow(marked) == 5){
    marked <- 
    marked %>% 
      mutate(winner = 100)
    return(out <- list(boards = marked, selection = selection))
  } else if(length(col_win_card)>0){
    marked <- 
    marked %>% 
      filter(!card_number %in% col_win_card)
  }
  
  out <- list(boards = marked, selection = selection)
  
  return(out)
  
}

mark_board_2_poss <- possibly(mark_board_2, otherwise = NULL)

winning_card <-
selections %>% 
  accumulate(mark_board_2_poss, .init = boards_list) %>% 
  discard(is.null) %>% 
  pluck(length(.))

winning_card$boards %>% 
  select(V1:V5) %>% 
  mutate(across(everything(), ~as.numeric(.))) %>% 
  as.matrix() %>% sum(na.rm = T) %>% prod(as.numeric(winning_card$selection))
```


## [Day 3](https://adventofcode.com/2021/day/3)

I rely on several pivots, `unite()`, and the iterative function `purrr::reduce()` for this problem. 

#### Part 1

```{r}
tibble(binary = read_lines("day_3.txt")) %>% 
  transmute(col = str_split_fixed(binary, pattern = "", n = nchar(binary))) %>% 
  pull(col) %>% as_tibble() %>% 
  summarise(across(.cols = everything(), .fns = ~if_else(mean(as.numeric(.))>.5,1,0))) %>% 
  pivot_longer(cols = everything(), values_to = "gamma", names_to = "slot")  %>% 
  mutate(epsilon = if_else(gamma == 1, 0, 1)) %>% 
  pivot_longer(cols = -slot) %>% 
  pivot_wider(names_from = slot, values_from = value) %>% 
  unite(col = "binary",  where(is.double), sep = "")  %>% 
  mutate(decimal = strtoi(as.double(binary), base = 2)) %>% 
  pull(decimal) %>% prod()
```

#### Part 2

```{r}
data <-
tibble(binary = read_lines("day_3.txt")) %>% 
  transmute(col = str_split_fixed(binary, pattern = "", n = nchar(binary))) %>% 
  pull(col) %>% as_tibble() %>% 
  summarise(across(.cols = everything(), .fns = ~as.numeric(.))) 

filter_rating <- function(data, col = "V1", type = "oxygen"){
  if(nrow(data)==1){out <- data} 
  else if(type == "oxygen"){out <- data[data[,col]==if_else(mean(data[,col][[1]])>=.5,1,0),]}
  else if(type == "co2"){out <- data[data[,col]==if_else(mean(data[,col][[1]])<.5,1,0),]}
}
  
reduce(.x = names(data), .f = filter_rating, .init = data, "oxygen") %>%
  unite(col = "binary",everything(), sep = "") %>% 
  pull() %>% strtoi(base = 2) *

reduce(.x = names(data), .f = filter_rating, .init = data, "co2") %>%
  unite(col = "binary",everything(), sep = "") %>% 
  pull() %>% strtoi(base = 2)

```


## [Day 2](https://adventofcode.com/2021/day/2)

Today I used `seperate()` and `cumsum()` to work this problem.

#### Part 1

```{r}
tibble(x = read_lines("day_2.txt")) %>% 
  separate(col = x, into = c("direction","distance"), convert = TRUE) %>% 
  group_by(real_direction = direction == "forward") %>% 
  mutate(distance = ifelse(direction == "up", distance * -1, distance)) %>% 
  summarise(movement = sum(distance)) %>% 
  pull(movement) %>% prod()
```

#### Part 2

```{r}
tibble(x = read_lines("day_2.txt")) %>% 
  separate(col = x, into = c("direction","distance"), convert = TRUE) %>%
  mutate(distance = as.double(distance)) %>% 
  mutate(aim_change = case_when(direction == "forward" ~ 0,
                                direction == "down" ~ distance,
                                direction == "up" ~ -1 * distance)) %>% 
  mutate(aim = cumsum(aim_change)) %>% 
  mutate(horizontal_position_increase = ifelse(direction == "forward", distance, 0)) %>% 
  mutate(depth_position_increase = ifelse(direction == "forward", aim * distance,0)) %>% 
  mutate(horizontal_position = cumsum(horizontal_position_increase)) %>% 
  mutate(depth_position = cumsum(depth_position_increase)) %>% 
  slice_tail(n = 1) %>% 
  summarise(answer = horizontal_position * depth_position) 

```


### [Day 1](https://adventofcode.com/2021/day/1)

Using `lag()` and `zoo::rollsum()` we are able to accomplish day one pretty easily.

#### Part 1

```{r}
tibble(measurements = as.numeric(read_lines("day1.txt"))) %>%  
  filter(measurements > lag(measurements,1)) %>% 
  nrow()
```

#### Part 2

```{r}
tibble(measurements = as.numeric(read_lines("day1.txt"))) %>%
  mutate(roll_sum = zoo::rollsum(measurements,3, fill = NA, align = "right")) %>%
  filter(roll_sum > lag(roll_sum,1)) %>%
  nrow()
```

